<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Transforms · LLVM.jl</title><meta name="title" content="Transforms · LLVM.jl"/><meta property="og:title" content="Transforms · LLVM.jl"/><meta property="twitter:title" content="Transforms · LLVM.jl"/><meta name="description" content="Documentation for LLVM.jl."/><meta property="og:description" content="Documentation for LLVM.jl."/><meta property="twitter:description" content="Documentation for LLVM.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">LLVM.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Usage</span><ul><li><a class="tocitem" href="../essentials/">Essentials</a></li><li><a class="tocitem" href="../types/">Types</a></li><li><a class="tocitem" href="../values/">Values</a></li><li><a class="tocitem" href="../modules/">Modules</a></li><li><a class="tocitem" href="../functions/">Functions</a></li><li><a class="tocitem" href="../blocks/">Basic blocks</a></li><li><a class="tocitem" href="../instructions/">Instructions</a></li><li><a class="tocitem" href="../metadata/">Metadata</a></li><li><a class="tocitem" href="../analyses/">Analyses</a></li><li class="is-active"><a class="tocitem" href>Transforms</a><ul class="internal"><li><a class="tocitem" href="#Pass-builders"><span>Pass builders</span></a></li><li><a class="tocitem" href="#Passes"><span>Passes</span></a></li><li><a class="tocitem" href="#Pass-managers"><span>Pass managers</span></a></li><li><a class="tocitem" href="#Alias-analyses"><span>Alias analyses</span></a></li><li><a class="tocitem" href="#Custom-passes"><span>Custom passes</span></a></li><li><a class="tocitem" href="#IR-cloning"><span>IR cloning</span></a></li></ul></li><li><a class="tocitem" href="../codegen/">Code generation</a></li><li><a class="tocitem" href="../execution/">Execution</a></li><li><a class="tocitem" href="../interop/">Julia integration</a></li></ul></li><li><span class="tocitem">API reference</span><ul><li><a class="tocitem" href="../../lib/essentials/">Essentials</a></li><li><a class="tocitem" href="../../lib/types/">Types</a></li><li><a class="tocitem" href="../../lib/values/">Values</a></li><li><a class="tocitem" href="../../lib/modules/">Modules</a></li><li><a class="tocitem" href="../../lib/functions/">Functions</a></li><li><a class="tocitem" href="../../lib/blocks/">Basic blocks</a></li><li><a class="tocitem" href="../../lib/instructions/">Instructions</a></li><li><a class="tocitem" href="../../lib/metadata/">Metadata</a></li><li><a class="tocitem" href="../../lib/analyses/">Analyses</a></li><li><a class="tocitem" href="../../lib/transforms/">Transforms</a></li><li><a class="tocitem" href="../../lib/codegen/">Code generation</a></li><li><a class="tocitem" href="../../lib/execution/">Execution</a></li><li><a class="tocitem" href="../../lib/interop/">Julia integration</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Usage</a></li><li class="is-active"><a href>Transforms</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Transforms</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/maleadt/LLVM.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/maleadt/LLVM.jl/blob/master/docs/src/man/transforms.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Transforms"><a class="docs-heading-anchor" href="#Transforms">Transforms</a><a id="Transforms-1"></a><a class="docs-heading-anchor-permalink" href="#Transforms" title="Permalink"></a></h1><p>LLVM contains a variety of passes that can be used to transform IR. With LLVM.jl, it is also possible to write your own passes in Julia. In this section, we will demonstrate the new pass manager interface; the legacy pass manager is being deprecated, and not recommended for new code.</p><h2 id="Pass-builders"><a class="docs-heading-anchor" href="#Pass-builders">Pass builders</a><a id="Pass-builders-1"></a><a class="docs-heading-anchor-permalink" href="#Pass-builders" title="Permalink"></a></h2><p>The core abstraction for running passes is the <code>NewPMPassBuilder</code> object, which aggregates passes via the <code>add!</code> function and runs them over a function or module using the <code>run!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; @dispose pb=NewPMPassBuilder() begin
         add!(pb, &quot;loop-unroll&quot;)
         run!(pb, mod)
       end</code></pre><p>When only running a single pass or pipeline, it is possible to bypass the construction of the pass builder and directly use the <code>run!</code> function:</p><pre><code class="language-julia-repl hljs">julia&gt; run!(&quot;loop-unroll&quot;, mod)</code></pre><p>Pass builders also support a number of keyword argument, mostly for debugging purposes. Refer to the <code>NewPMPassBuilder</code> docstring for more details.</p><h2 id="Passes"><a class="docs-heading-anchor" href="#Passes">Passes</a><a id="Passes-1"></a><a class="docs-heading-anchor-permalink" href="#Passes" title="Permalink"></a></h2><p>In LLVM&#39;s new pass manager, passes are simply strings, as shown above. In LLVM.jl, we also expose objects for each pass, which helps to avoid typos in pass names, and simplifies passing arguments to the pass.</p><p>The <code>loop-unroll</code> pass from above, for example, can also be constructed using the <code>LoopUnrollPass</code> object, which simplifies setting options for the pass:</p><pre><code class="language-julia-repl hljs">julia&gt; run!(LoopUnrollPass(; allow_partial=true), mod)</code></pre><h3 id="Pipelines"><a class="docs-heading-anchor" href="#Pipelines">Pipelines</a><a id="Pipelines-1"></a><a class="docs-heading-anchor-permalink" href="#Pipelines" title="Permalink"></a></h3><p>Pipelines, such as LLVM&#39;s default pipeline, are similarly represented by either strings (<code>&quot;default&quot;</code>), or objects (<code>DefaultPipeline</code>), both of which supporting options (resp. <code>&quot;default&lt;O3&gt;&quot;</code> and <code>DefaultPipeline(; opt_level=3)</code>).</p><p>LLVM&#39;s default pipeline doesn&#39;t support many options (as opposed to, e.g., Julia&#39;s pipeline). Instead, the pipeline can be tuned through pipeline tuning keyword arguments that have to be set on the <code>PassBuilder</code> object. Refer to the <code>NewPMPasBuilder</code> docstrings for more details.</p><h2 id="Pass-managers"><a class="docs-heading-anchor" href="#Pass-managers">Pass managers</a><a id="Pass-managers-1"></a><a class="docs-heading-anchor-permalink" href="#Pass-managers" title="Permalink"></a></h2><p>When running or adding passes directly to a pass builder, LLVM will guess the appropriate pass manager to use. When combining multiple types of passes, it is required to manually construct the appropriate pass manager:</p><pre><code class="language-julia-repl hljs">julia&gt; @dispose pb=NewPMPassBuilder() begin
         add!(pb, NewPMModulePassManager()) do mpm
           add!(mpm, NoOpModulePass())
           add!(mpm, NewPMFunctionPassManager()) do fpm
             add!(fpm, NoOpFunctionPass())
             add!(fpm, NewPMLoopPassManager()) do lpm
               add!(lpm, NoOpLoopPass())
             end
           end
         end
         run!(pb, mod)
       end</code></pre><h2 id="Alias-analyses"><a class="docs-heading-anchor" href="#Alias-analyses">Alias analyses</a><a id="Alias-analyses-1"></a><a class="docs-heading-anchor-permalink" href="#Alias-analyses" title="Permalink"></a></h2><p>When not specified, LLVM will use the default alias analyses passes when optimizing code. It is possible to customize this selection through the <code>AAManager</code> object. This object behaves like other pass managers, and alias analysis passes can similarly to regular passes be constructed by name or by object:</p><pre><code class="language-julia-repl hljs">julia&gt; @dispose pb=NewPMPassBuilder() begin
         add!(pb, NewPMAAManager()) do aam
           add!(aam, &quot;basic-aa&quot;)
           add!(aam, SCEVAA())
         end
         add!(pb, &quot;aa-eval&quot;)
         run!(pb, mod)
       end</code></pre><h2 id="Custom-passes"><a class="docs-heading-anchor" href="#Custom-passes">Custom passes</a><a id="Custom-passes-1"></a><a class="docs-heading-anchor-permalink" href="#Custom-passes" title="Permalink"></a></h2><p>Simple LLVM passes can be implemented in Julia by defining a function that takes a single argument (a module or function), and returns a boolean indicating whether the module or function was modified. This function is then to be wrapped in a <code>ModulePass</code> or <code>FunctionPass</code> object, and registered with the pass builder:</p><pre><code class="language-julia-repl hljs">julia&gt; function custom_module_pass!(mod::LLVM.Module)
         println(&quot;Hello, World!&quot;)
         return false
       end;

julia&gt; CustomModulePass() = NewPMModulePass(&quot;custom_module_pass&quot;, custom_module_pass!);

julia&gt; @dispose pb=NewPMPassBuilder() begin
         register!(pb, CustomModulePass())
         add!(pb, CustomModulePass())
         run!(pb, mod)
       end
Hello, World!</code></pre><h2 id="IR-cloning"><a class="docs-heading-anchor" href="#IR-cloning">IR cloning</a><a id="IR-cloning-1"></a><a class="docs-heading-anchor-permalink" href="#IR-cloning" title="Permalink"></a></h2><p>Somewhat distinct from IR passes, it is also possible to clone bits of the IR. This can be useful when you want to keep the original version of the IR around, or when you have to fundamentally change the IR in a way that requires recreating the IR (e.g., when changing a function type).</p><p>The workhorse for this is the <code>clone_into!</code> function, which takes a source and a destination function, cloning the source into the destination:</p><pre><code class="language-julia-repl hljs">julia&gt; src
define i64 @add(i64 %0, i64 %1) {
top:
  %2 = add i64 %1, %0
  ret i64 %2
}

julia&gt; dst = LLVM.Function(mod, &quot;new_add&quot;, function_type(src));

julia&gt; value_map = Dict(
            parameters(src)[1] =&gt; parameters(dst)[1],
            parameters(src)[2] =&gt; parameters(dst)[2]
       );

julia&gt; clone_into!(dst, src; value_map);

julia&gt; dst
define i64 @new_add(i64 %0, i64 %1) {
top:
  %2 = add i64 %1, %0
  ret i64 %2
}</code></pre><p>Note how we had to provide a value map to map the arguments of the source function to the arguments of the new destination function. This is a powerful tool, which makes it possible to splice IR into functions that have different signatures:</p><pre><code class="language-julia-repl hljs">julia&gt; dst = LLVM.Function(mod, &quot;new_add&quot;, function_type(src));

julia&gt; # let&#39;s swap the arguments around
       value_map = Dict(
            parameters(src)[1] =&gt; parameters(dst)[2],
            parameters(src)[2] =&gt; parameters(dst)[1]
       );

julia&gt; clone_into!(dst, src; value_map);

julia&gt; dst
define i64 @new_add(i64 %0, i64 %1) {
top:
  %2 = add i64 %0, %1
  ret i64 %2
}</code></pre><p>It is also possible to map types using the <code>type_mapper</code> callback, or to materialize values by passing a <code>materializer</code> callback. Refer to the upstream LLVM documentation for more details.</p><p>For the simpler use case of just cloning a function and mapping values, the <code>clone</code> function can be used:</p><pre><code class="language-julia-repl hljs">julia&gt; # let&#39;s replace an argument by a constant
       value_map = Dict(
            parameters(src)[1] =&gt; ConstantInt(42)
       );

julia&gt; clone(src; value_map)
define i64 @add.1(i64 %0) {
top:
  %1 = add i64 %0, 42
  ret i64 %1
}</code></pre><p>Finally, it is also possible to clone just a basic block, inserting it at the end of a function. This differs from a simple call to <code>copy</code> in that it also accepts a value map:</p><pre><code class="language-julia-repl hljs">julia&gt; bb = entry(src);

julia&gt; # let&#39;s again an argument by a constant
       value_map = Dict(
            parameters(src)[1] =&gt; ConstantInt(42)
       );

julia&gt; clone(bb; value_map);

julia&gt; src
define i64 @add(i64 %0, i64 %1) {
top:
  %2 = add i64 %1, %0
  ret i64 %2

top1:                                             ; No predecessors!
  %3 = add i64 %1, 42
  ret i64 %3
}</code></pre><p>This of course isn&#39;t very useful by itself, but can be a useful starting point for more complex transformations.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../analyses/">« Analyses</a><a class="docs-footer-nextpage" href="../codegen/">Code generation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.7.0 on <span class="colophon-date" title="Tuesday 15 October 2024 09:41">Tuesday 15 October 2024</span>. Using Julia version 1.10.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
