var documenterSearchIndex = {"docs":
[{"location":"lib/execution/#Execution","page":"Execution","title":"Execution","text":"","category":"section"},{"location":"lib/execution/#Generic-Value","page":"Execution","title":"Generic Value","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"GenericValue\ndispose(::GenericValue)","category":"page"},{"location":"lib/execution/#LLVM.GenericValue","page":"Execution","title":"LLVM.GenericValue","text":"GenericValue\n\nA generic value that can be passed to or returned from a function in the execution engine.\n\nNote that only simple types are supported, and for most use cases it is recommended to look up the address of the compiled function and ccall it directly.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.dispose-Tuple{GenericValue}","page":"Execution","title":"LLVM.dispose","text":"dispose(val::GenericValue)\n\nDispose of the given generic value.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Integer","page":"Execution","title":"Integer","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"GenericValue(::LLVM.IntegerType, ::Integer)\nintwidth\nconvert(::Type{T}, val::GenericValue) where {T <: Integer}","category":"page"},{"location":"lib/execution/#LLVM.GenericValue-Tuple{LLVM.IntegerType, Integer}","page":"Execution","title":"LLVM.GenericValue","text":"GenericValue(typ::LLVM.IntegerType, N::Integer)\n\nCreate a generic value from an integer of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.intwidth","page":"Execution","title":"LLVM.intwidth","text":"intwidth(val::GenericValue)\n\nGet the bit width of the integer value stored in the generic value.\n\n\n\n\n\n","category":"function"},{"location":"lib/execution/#Base.convert-Union{Tuple{T}, Tuple{Type{T}, GenericValue}} where T<:Integer","page":"Execution","title":"Base.convert","text":"convert(::Type{<:Integer}, val::GenericValue)\n\nConvert a generic value to an integer of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Floating-Point","page":"Execution","title":"Floating Point","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"GenericValue(::LLVM.FloatingPointType, ::AbstractFloat)\nconvert(::Type{T}, val::GenericValue, typ::LLVMType) where {T<:AbstractFloat}","category":"page"},{"location":"lib/execution/#LLVM.GenericValue-Tuple{LLVM.FloatingPointType, AbstractFloat}","page":"Execution","title":"LLVM.GenericValue","text":"GenericValue(typ::LLVM.FloatingPointType, N::AbstractFloat)\n\nCreate a generic value from a floating point number of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Base.convert-Union{Tuple{T}, Tuple{Type{T}, GenericValue, LLVMType}} where T<:AbstractFloat","page":"Execution","title":"Base.convert","text":"convert(::Type{<:AbstractFloat}, val::GenericValue, typ::LLVM.FloatingPointType)\n\nConvert a generic value to a floating point number of the given type.\n\nContrary to the integer conversion, the LLVM type is also required to be passed explicitly.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Pointer","page":"Execution","title":"Pointer","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"GenericValue(::Ptr)\nconvert(::Type{Ptr{T}}, ::GenericValue) where T","category":"page"},{"location":"lib/execution/#LLVM.GenericValue-Tuple{Ptr}","page":"Execution","title":"LLVM.GenericValue","text":"GenericValue(ptr::Ptr)\n\nCreate a generic value from a pointer.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Base.convert-Union{Tuple{T}, Tuple{Type{Ptr{T}}, GenericValue}} where T","page":"Execution","title":"Base.convert","text":"convert(::Type{Ptr{T}}, val::GenericValue)\n\nConvert a generic value to a pointer.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#MCJIT","page":"Execution","title":"MCJIT","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"LLVM.ExecutionEngine\nInterpreter\nJIT\ndispose(::LLVM.ExecutionEngine)\nBase.push!(::LLVM.ExecutionEngine, ::LLVM.Module)\nBase.delete!(::LLVM.ExecutionEngine, ::LLVM.Module)\nrun(::LLVM.ExecutionEngine, ::LLVM.Function, ::Vector{GenericValue})\nlookup(::LLVM.ExecutionEngine, ::String)\nfunctions(::LLVM.ExecutionEngine)","category":"page"},{"location":"lib/execution/#LLVM.ExecutionEngine","page":"Execution","title":"LLVM.ExecutionEngine","text":"LLVM.ExecutionEngine\n\nAn execution engine that can run functions in a module.\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.Interpreter","page":"Execution","title":"LLVM.Interpreter","text":"Interpreter(mod::Module)\n\nCreate an interpreter for the given module.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"function"},{"location":"lib/execution/#LLVM.JIT","page":"Execution","title":"LLVM.JIT","text":"JIT(mod::Module)\n\nCreate a JIT compiler for the given module.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"function"},{"location":"lib/execution/#LLVM.dispose-Tuple{LLVM.ExecutionEngine}","page":"Execution","title":"LLVM.dispose","text":"dispose(engine::ExecutionEngine)\n\nDispose of the given execution engine.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Base.push!-Tuple{LLVM.ExecutionEngine, LLVM.Module}","page":"Execution","title":"Base.push!","text":"push!(engine::LLVM.ExecutionEngine, mod::Module)\n\nAdd another module to the execution engine.\n\nThis takes ownership of the module.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Base.delete!-Tuple{LLVM.ExecutionEngine, LLVM.Module}","page":"Execution","title":"Base.delete!","text":"delete!(engine::ExecutionEngine, mod::Module)\n\nRemove a module from the execution engine.\n\nOwnership of the module is transferred back to the user.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#Base.run-Tuple{LLVM.ExecutionEngine, LLVM.Function, Vector{GenericValue}}","page":"Execution","title":"Base.run","text":"run(engine::ExecutionEngine, f::Function, [args::Vector{GenericValue}])\n\nRun the given function with the given arguments in the execution engine.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.lookup-Tuple{LLVM.ExecutionEngine, String}","page":"Execution","title":"LLVM.lookup","text":"lookup(engine::ExecutionEngine, fn::String)\n\nLook up the address of the given function in the execution engine.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.functions-Tuple{LLVM.ExecutionEngine}","page":"Execution","title":"LLVM.functions","text":"functions(engine::ExecutionEngine)\n\nGet an iterator over the functions in the execution engine.\n\nThe iterator object is not actually iterable, but supports get and haskey queries with function names, and getindex to get the function object.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#ORCJIT","page":"Execution","title":"ORCJIT","text":"","category":"section"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"ThreadSafeContext\nThreadSafeContext()\ncontext(::ThreadSafeContext)\ndispose(::ThreadSafeContext)\nThreadSafeModule\nThreadSafeModule(::String)\nThreadSafeModule(::Module)\ndispose(::ThreadSafeModule)","category":"page"},{"location":"lib/execution/#LLVM.ThreadSafeContext","page":"Execution","title":"LLVM.ThreadSafeContext","text":"ThreadSafeContext\n\nA thread-safe version of Context.\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.ThreadSafeContext-Tuple{}","page":"Execution","title":"LLVM.ThreadSafeContext","text":"ThreadSafeContext(; opaque_pointers=nothing)\n\nCreate a new thread-safe context. The behavior of opaque_pointers is the same as in Context.\n\nThis object needs to be disposed of using dispose(::ThreadSafeContext).\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.context-Tuple{ThreadSafeContext}","page":"Execution","title":"LLVM.context","text":"context(ts_ctx::ThreadSafeContext)\n\nObtain the context associated with a thread-safe context.\n\nwarning: Warning\nThis is an usafe operation, as the return context can be accessed in a thread-unsafe manner.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.dispose-Tuple{ThreadSafeContext}","page":"Execution","title":"LLVM.dispose","text":"dispose(ctx::ThreadSafeContext)\n\nDispose of the thread-safe context, releasing all resources associated with it.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.ThreadSafeModule","page":"Execution","title":"LLVM.ThreadSafeModule","text":"ThreadSafeModule\n\nA thread-safe version of LLVM.Module.\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.ThreadSafeModule-Tuple{String}","page":"Execution","title":"LLVM.ThreadSafeModule","text":"ThreadSafeModule(name::String)\n\nCreate a thread-safe module with the given name.\n\nThis object needs to be disposed of using dispose(::ThreadSafeModule).\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.ThreadSafeModule-Tuple{Module}","page":"Execution","title":"LLVM.ThreadSafeModule","text":"(mod::ThreadSafeModule)(f)\n\nApply f to the LLVM module contained within mod, after locking the module and activating its context.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.dispose-Tuple{ThreadSafeModule}","page":"Execution","title":"LLVM.dispose","text":"dispose(mod::ThreadSafeModule)\n\nDispose of the thread-safe module, releasing all resources associated with it.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/","page":"Execution","title":"Execution","text":"LLJIT\nJITDylib\nlookup(::LLJIT, ::Any)\nlinkinglayercreator!","category":"page"},{"location":"lib/execution/#LLVM.LLJIT","page":"Execution","title":"LLVM.LLJIT","text":"LLJIT(::LLJITBuilder)\n\nCreates a LLJIT stack based on the provided builder.\n\nnote: Note\nTakes ownership of the provided builder.\n\n\n\n\n\nLLJIT(;tm::Union{Nothing, TargetMachine})\n\nUse the provided TargetMachine and construct an LLJIT from it.\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.JITDylib","page":"Execution","title":"LLVM.JITDylib","text":"JITDylib(lljit::LLJIT)\n\nGet the main JITDylib\n\n\n\n\n\nJITDylib(es::ExecutionSession, name; bare=false)\n\nAdds a new JITDylib to the ExecutionSession. The name must be unique and the bare=true no standard platform symbols are made available.\n\n\n\n\n\nJITDylib(jljit::JuliaOJIT)\n\nGet the external JITDylib from the Julia JIT\n\n\n\n\n\n","category":"type"},{"location":"lib/execution/#LLVM.lookup-Tuple{LLJIT, Any}","page":"Execution","title":"LLVM.lookup","text":"lookup(lljit::LLJIT, name)\n\nTakes an unmangled symbol names and searches for it in the LLJIT.\n\n\n\n\n\n","category":"method"},{"location":"lib/execution/#LLVM.linkinglayercreator!","page":"Execution","title":"LLVM.linkinglayercreator!","text":"linkinglayercreator!(builder::LLJITBuilder, creator::ObjectLinkingLayerCreator)\n\nwarning: Warning\nThe creator object needs to be rooted by the caller for the lifetime of the builder argument.\n\n\n\n\n\n","category":"function"},{"location":"lib/blocks/#Basic-blocks","page":"Basic blocks","title":"Basic blocks","text":"","category":"section"},{"location":"lib/blocks/","page":"Basic blocks","title":"Basic blocks","text":"BasicBlock\nBasicBlock(name::String)\nBasicBlock(f::LLVM.Function, name::String)\nBasicBlock(bb::BasicBlock, name::String)","category":"page"},{"location":"lib/blocks/#LLVM.BasicBlock","page":"Basic blocks","title":"LLVM.BasicBlock","text":"BasicBlock\n\nA basic block in the IR. A basic block is a sequence of instructions that always ends in a terminator instruction.\n\n\n\n\n\n","category":"type"},{"location":"lib/blocks/#LLVM.BasicBlock-Tuple{String}","page":"Basic blocks","title":"LLVM.BasicBlock","text":"BasicBlock(name::String)\n\nCreate a new, empty basic block with the given name.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.BasicBlock-Tuple{LLVM.Function, String}","page":"Basic blocks","title":"LLVM.BasicBlock","text":"BasicBlock(f::LLVM.Function, name::String)\n\nCreate a new, empty basic block with the given name, and insert it at the end of the given function.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.BasicBlock-Tuple{BasicBlock, String}","page":"Basic blocks","title":"LLVM.BasicBlock","text":"BasicBlock(bb::BasicBlock, name::String)\n\nCreate a new, empty basic block with the given name, and insert it before the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#Properties-and-operations","page":"Basic blocks","title":"Properties and operations","text":"","category":"section"},{"location":"lib/blocks/","page":"Basic blocks","title":"Basic blocks","text":"remove!(::BasicBlock)\nerase!(::BasicBlock)\nLLVM.parent(::BasicBlock)\nterminator(::BasicBlock)\nname(::BasicBlock)\nmove_before\nmove_after","category":"page"},{"location":"lib/blocks/#LLVM.remove!-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.remove!","text":"remove!(bb::BasicBlock)\n\nRemove the given basic block from its parent function, but do not free the object.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.erase!-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.erase!","text":"erase!(fun::Function, bb::BasicBlock)\n\nRemove the given basic block from its parent function and free the object.\n\nwarning: Warning\nThis function is unsafe because it does not check if the basic block is used elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.parent-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.parent","text":"parent(bb::BasicBlock) -> LLVM.Function\n\nGet the function that contains the given basic block, or nothing if the block is not part of a function.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.terminator-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.terminator","text":"terminator(bb::BasicBlock) -> LLVM.Instruction\n\nGet the terminator instruction of the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.name-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.name","text":"name(bb::BasicBlock) -> String\n\nGet the name of the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.move_before","page":"Basic blocks","title":"LLVM.move_before","text":"move_before(bb::BasicBlock, pos::BasicBlock)\n\nMove the given basic block before the given position.\n\n\n\n\n\n","category":"function"},{"location":"lib/blocks/#LLVM.move_after","page":"Basic blocks","title":"LLVM.move_after","text":"move_after(bb::BasicBlock, pos::BasicBlock)\n\nMove the given basic block after the given position.\n\n\n\n\n\n","category":"function"},{"location":"lib/blocks/#Control-flow","page":"Basic blocks","title":"Control flow","text":"","category":"section"},{"location":"lib/blocks/","page":"Basic blocks","title":"Basic blocks","text":"predecessors(::BasicBlock)\nsuccessors(::BasicBlock)","category":"page"},{"location":"lib/blocks/#LLVM.predecessors-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.predecessors","text":"predecessors(bb::BasicBlock)\n\nGet the predecessors of the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#LLVM.successors-Tuple{BasicBlock}","page":"Basic blocks","title":"LLVM.successors","text":"successors(bb::BasicBlock)\n\nGet the successors of the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/blocks/#Instructions","page":"Basic blocks","title":"Instructions","text":"","category":"section"},{"location":"lib/blocks/","page":"Basic blocks","title":"Basic blocks","text":"instructions\nprevinst\nnextinst","category":"page"},{"location":"lib/blocks/#LLVM.instructions","page":"Basic blocks","title":"LLVM.instructions","text":"instructions(bb::BasicBlock)\n\nGet an iterator over the instructions in the given basic block.\n\n\n\n\n\n","category":"function"},{"location":"lib/blocks/#LLVM.previnst","page":"Basic blocks","title":"LLVM.previnst","text":"previnst(inst::Instruction)\n\nGet the instruction before the given instruction in the basic block, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"lib/blocks/#LLVM.nextinst","page":"Basic blocks","title":"LLVM.nextinst","text":"nextinst(inst::Instruction)\n\nGet the instruction after the given instruction in the basic block, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks/#Basic-blocks","page":"Basic blocks","title":"Basic blocks","text":"","category":"section"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"Basic blocks are sequences of instructions that are executed in order. They are the building blocks of functions, and can be looked up using the blocks iterator, or by constructing them directly:","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"julia> bb = BasicBlock(\"SomeBlock\")\nSomeBlock:                                        ; No predecessors!","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"A detached basic block often not what you want; using the BasicBlock(::Function) constructor you can instead append to a function, or insert before another block using the BasicBlock(::BasicBlock) constructor.","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"Basic blocks support a couple of specific APIs:","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"name: the name of the basic block.\nparent: the parent function of the basic block, or nothing if it is detached.\nterminator: get the terminator instruction of the block.\nmove_before/move_after: move the block before or after another block.\nremove!/erase!: delete the basic block from its parent function, or additionally also delete the block itself.","category":"page"},{"location":"man/blocks/#Control-flow","page":"Basic blocks","title":"Control flow","text":"","category":"section"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"The LLVM C API supports a couple of functions to inspect the control flow of basic blocks:","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"predecessors: get the predecessors of a basic block.\nsuccessors: get the successors of a basic block.","category":"page"},{"location":"man/blocks/#Instructions","page":"Basic blocks","title":"Instructions","text":"","category":"section"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n        define i64 @\"add\"(i64 %0, i64 %1) {\n        top:\n          %2 = add i64 %1, %0\n          ret i64 %2\n        }\"\"\"\n    mod = parse(LLVM.Module, ir);\n    fun = only(functions(mod));\n    bb = entry(fun)\nend","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"The main purpose of basic blocks is to contain instructions, which can be iterated using the instructions function:","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"julia> bb\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n\njulia> collect(instructions(bb))\n2-element Vector{Instruction}:\n %2 = add i64 %1, %0\n ret i64 %2","category":"page"},{"location":"man/blocks/","page":"Basic blocks","title":"Basic blocks","text":"In addition to the iteration interface, it is possible to move from one instruction to the previous or next one using respectively the previnst and nextinst functions.","category":"page"},{"location":"man/transforms/#Transforms","page":"Transforms","title":"Transforms","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    mod = LLVM.Module(\"SomeModule\")\nend","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"LLVM contains a variety of passes that can be used to transform IR. With LLVM.jl, it is also possible to write your own passes in Julia. In this section, we will demonstrate the new pass manager interface; the legacy pass manager is being deprecated, and not recommended for new code.","category":"page"},{"location":"man/transforms/#Pass-builders","page":"Transforms","title":"Pass builders","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"The core abstraction for running passes is the NewPMPassBuilder object, which aggregates passes via the add! function and runs them over a function or module using the run! function:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> @dispose pb=NewPMPassBuilder() begin\n         add!(pb, \"loop-unroll\")\n         run!(pb, mod)\n       end","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"When only running a single pass or pipeline, it is possible to bypass the construction of the pass builder and directly use the run! function:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> run!(\"loop-unroll\", mod)","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Pass builders also support a number of keyword argument, mostly for debugging purposes. Refer to the NewPMPassBuilder docstring for more details.","category":"page"},{"location":"man/transforms/#Passes","page":"Transforms","title":"Passes","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"In LLVM's new pass manager, passes are simply strings, as shown above. In LLVM.jl, we also expose objects for each pass, which helps to avoid typos in pass names, and simplifies passing arguments to the pass.","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"The loop-unroll pass from above, for example, can also be constructed using the LoopUnrollPass object, which simplifies setting options for the pass:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> run!(LoopUnrollPass(; allow_partial=true), mod)","category":"page"},{"location":"man/transforms/#Pipelines","page":"Transforms","title":"Pipelines","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Pipelines, such as LLVM's default pipeline, are similarly represented by either strings (\"default\"), or objects (DefaultPipeline), both of which supporting options (resp. \"default<O3>\" and DefaultPipeline(; opt_level=3)).","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"LLVM's default pipeline doesn't support many options (as opposed to, e.g., Julia's pipeline). Instead, the pipeline can be tuned through pipeline tuning keyword arguments that have to be set on the PassBuilder object. Refer to the NewPMPasBuilder docstrings for more details.","category":"page"},{"location":"man/transforms/#Pass-managers","page":"Transforms","title":"Pass managers","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"When running or adding passes directly to a pass builder, LLVM will guess the appropriate pass manager to use. When combining multiple types of passes, it is required to manually construct the appropriate pass manager:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> @dispose pb=NewPMPassBuilder() begin\n         add!(pb, NewPMModulePassManager()) do mpm\n           add!(mpm, NoOpModulePass())\n           add!(mpm, NewPMFunctionPassManager()) do fpm\n             add!(fpm, NoOpFunctionPass())\n             add!(fpm, NewPMLoopPassManager()) do lpm\n               add!(lpm, NoOpLoopPass())\n             end\n           end\n         end\n         run!(pb, mod)\n       end","category":"page"},{"location":"man/transforms/#Alias-analyses","page":"Transforms","title":"Alias analyses","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"When not specified, LLVM will use the default alias analyses passes when optimizing code. It is possible to customize this selection through the AAManager object. This object behaves like other pass managers, and alias analysis passes can similarly to regular passes be constructed by name or by object:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> @dispose pb=NewPMPassBuilder() begin\n         add!(pb, NewPMAAManager()) do aam\n           add!(aam, \"basic-aa\")\n           add!(aam, SCEVAA())\n         end\n         add!(pb, \"aa-eval\")\n         run!(pb, mod)\n       end","category":"page"},{"location":"man/transforms/#Custom-passes","page":"Transforms","title":"Custom passes","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Simple LLVM passes can be implemented in Julia by defining a function that takes a single argument (a module or function), and returns a boolean indicating whether the module or function was modified. This function is then to be wrapped in a ModulePass or FunctionPass object, and registered with the pass builder:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> function custom_module_pass!(mod::LLVM.Module)\n         println(\"Hello, World!\")\n         return false\n       end;\n\njulia> CustomModulePass() = NewPMModulePass(\"custom_module_pass\", custom_module_pass!);\n\njulia> @dispose pb=NewPMPassBuilder() begin\n         register!(pb, CustomModulePass())\n         add!(pb, CustomModulePass())\n         run!(pb, mod)\n       end\nHello, World!","category":"page"},{"location":"man/transforms/#IR-cloning","page":"Transforms","title":"IR cloning","text":"","category":"section"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Somewhat distinct from IR passes, it is also possible to clone bits of the IR. This can be useful when you want to keep the original version of the IR around, or when you have to fundamentally change the IR in a way that requires recreating the IR (e.g., when changing a function type).","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"The workhorse for this is the clone_into! function, which takes a source and a destination function, cloning the source into the destination:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n             define i64 @\"add\"(i64 %0, i64 %1) {\n             top:\n               %2 = add i64 %1, %0\n               ret i64 %2\n             }\"\"\";\n    mod = parse(LLVM.Module, ir);\n    src = functions(mod)[\"add\"];\nend","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> src\ndefine i64 @add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}\n\njulia> dst = LLVM.Function(mod, \"new_add\", function_type(src));\n\njulia> value_map = Dict(\n            parameters(src)[1] => parameters(dst)[1],\n            parameters(src)[2] => parameters(dst)[2]\n       );\n\njulia> clone_into!(dst, src; value_map);\n\njulia> dst\ndefine i64 @new_add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Note how we had to provide a value map to map the arguments of the source function to the arguments of the new destination function. This is a powerful tool, which makes it possible to splice IR into functions that have different signatures:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> dst = LLVM.Function(mod, \"new_add\", function_type(src));\n\njulia> # let's swap the arguments around\n       value_map = Dict(\n            parameters(src)[1] => parameters(dst)[2],\n            parameters(src)[2] => parameters(dst)[1]\n       );\n\njulia> clone_into!(dst, src; value_map);\n\njulia> dst\ndefine i64 @new_add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %0, %1\n  ret i64 %2\n}","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"It is also possible to map types using the type_mapper callback, or to materialize values by passing a materializer callback. Refer to the upstream LLVM documentation for more details.","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"For the simpler use case of just cloning a function and mapping values, the clone function can be used:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> # let's replace an argument by a constant\n       value_map = Dict(\n            parameters(src)[1] => ConstantInt(42)\n       );\n\njulia> clone(src; value_map)\ndefine i64 @add.1(i64 %0) {\ntop:\n  %1 = add i64 %0, 42\n  ret i64 %1\n}","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"Finally, it is also possible to clone just a basic block, inserting it at the end of a function. This differs from a simple call to copy in that it also accepts a value map:","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"julia> bb = entry(src);\n\njulia> # let's again an argument by a constant\n       value_map = Dict(\n            parameters(src)[1] => ConstantInt(42)\n       );\n\njulia> clone(bb; value_map);\n\njulia> src\ndefine i64 @add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n\ntop1:                                             ; No predecessors!\n  %3 = add i64 %1, 42\n  ret i64 %3\n}","category":"page"},{"location":"man/transforms/","page":"Transforms","title":"Transforms","text":"This of course isn't very useful by itself, but can be a useful starting point for more complex transformations.","category":"page"},{"location":"man/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Functions are part of a module, and represent a callable piece of code. They can be looked up in a module using the functions iterator, or created from scratch:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> fty = LLVM.FunctionType(LLVM.VoidType(), [LLVM.Int32Type()])\nvoid (i32)\n\njulia> fun = LLVM.Function(mod, \"SomeFunction\", fty)\ndeclare void @SomeFunction(i32)","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Several APIs can be used to interact with functions:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"function_type: get the function type of the function (this differs from value_type, which will return a pointer to the function type).\npersonality/personality!: get or set the personality function of the function (pass nothing to remove the personality function).\ncallconv/callconv!: get or set the calling convention of the function.\ngc/gc!: get or set the garbage collector for the function.\nisintrinsic: check if the function is an intrinsic.\nerase!: delete the function from its parent module, and delete the object.","category":"page"},{"location":"man/functions/#Intrinsics","page":"Functions","title":"Intrinsics","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Intrinsic functions are special function declarations that are recognized by the LLVM compiler and possibly treated specially by the code generator. It is normally not necessary to create Intrinsic objects directly, as function declarations that match an intrinsic's name and signature will be treated as such:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> f = LLVM.Function(mod, \"llvm.trap\", LLVM.FunctionType(LLVM.VoidType()))\n; Function Attrs: cold noreturn nounwind\ndeclare void @llvm.trap() #0\n\njulia> isintrinsic(f)\ntrue","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"However, the Intrinsic type supports additional APIs:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"name: get the base name of the intrinsic, or a specific overloaded name by passing additional argument types.\nisoverloaded: check if the intrinsic is overloaded.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"It can also be useful to construct a function from a well-known intrinsic, to make sure the overloaded name is correct:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> intr = LLVM.Intrinsic(\"llvm.abs\")\nIntrinsic(1): overloaded intrinsic\n\njulia> isoverloaded(intr)\ntrue\n\njulia> LLVM.Function(mod, intr, [LLVM.Int32Type()])\n; Function Attrs: nocallback nofree nosync nounwind speculatable willreturn memory(none)\ndeclare i32 @llvm.abs.i32(i32, i1 immarg) #0","category":"page"},{"location":"man/functions/#Attributes","page":"Functions","title":"Attributes","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Functions can have attributes associated with them, which can be set and retrieved using the iterators returned by the function_attributes, parameter_attributes and return_attributes functions to respectively set attributes on the function, its parameters, and its return value:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> push!(function_attributes(fun), StringAttribute(\"nounwind\"))\n\njulia> push!(parameter_attributes(fun, 1), StringAttribute(\"nocapture\"))\n\njulia> push!(return_attributes(fun), StringAttribute(\"sret\"))\n\njulia> mod\n; ModuleID = 'SomeModule'\nsource_filename = \"SomeModule\"\n\ndeclare \"sret\" void @SomeFunction(i32 \"nocapture\") #0\n\nattributes #0 = { \"nounwind\" }","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Attributes can be removed from these iterators using the delete! function.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Different kinds of attributes are supported:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"EnumAttribute: an attribute identified by its enum id, optionally associated with an integer value.\nStringAttribute: an attribute identified by its string name, optionally associated with a string value\nTypeAttribute: an attribute identified by its enum id, associated with a type.","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> EnumAttribute(\"nounwind\")\nEnumAttribute 36=0\n\njulia> StringAttribute(\"frame-pointer\", \"none\")\nStringAttribute frame-pointer=none\n\njulia> TypeAttribute(\"byval\", LLVM.Int32Type())\nTypeAttribute 70=LLVM.IntegerType(i32)","category":"page"},{"location":"man/functions/#Parameters","page":"Functions","title":"Parameters","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Parameters are values that represent the arguments to a function, and can be used as operands to other values. They can be queried using the parameters function:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> collect(parameters(fun))\n1-element Vector{Argument}:\n i32 %0","category":"page"},{"location":"man/functions/#Basic-blocks","page":"Functions","title":"Basic blocks","text":"","category":"section"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n        define i64 @\"add\"(i64 %0, i64 %1) {\n        top:\n          %2 = add i64 %1, %0\n          ret i64 %2\n        }\"\"\"\n    mod = parse(LLVM.Module, ir);\n    fun = only(functions(mod));\nend","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"Functions are composed of basic blocks, which are sequences of instructions that are executed in order. Basic blocks can be iterated using the blocks function:","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"julia> fun\ndefine i64 @add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}\n\njulia> collect(blocks(fun))\n1-element Vector{BasicBlock}:\n BasicBlock(\"top\")\n\njulia> # to simply get the first block\n       entry(fun)\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2","category":"page"},{"location":"man/functions/","page":"Functions","title":"Functions","text":"In addition to the iteration interface, it is possible to move from one basic block to the previous or next one using respectively the prevblock and nextblock functions.","category":"page"},{"location":"man/interop/#Julia-integration","page":"Julia integration","title":"Julia integration","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"DocTestSetup = quote\n    using LLVM\n    using LLVM.Interop\n    using InteractiveUtils\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    mod = LLVM.Module(\"SomeModule\")\nend","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.jl offers several tools to interoperate with Julia's LLVM-based code generator. These tools are part of the Interop submodule, and need to be imported explicitly.","category":"page"},{"location":"man/interop/#Type-conversion","page":"Julia integration","title":"Type conversion","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"Julia types can be converted to their LLVM counterparts using the convert function.","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> convert(LLVMType, Int64)\ni64","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"By default, this conversion rejects boxed types, as the result would often be surprising. It is possible to query whether a type would be boxed using the isboxed function, and/or allow the conversion by passing allow_boxed=true to convert:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> isboxed(Int64)\nfalse\n\njulia> isboxed(String)\ntrue\n\njulia> convert(LLVMType, String; allow_boxed=true)\n{} addrspace(10)*","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"Another useful query is isghosttype, which returns whether a type is a ghost type, i.e., a sizeless type:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> isghosttype(Nothing)\ntrue\n\njulia> isghosttype(LLVM.VoidType())\ntrue","category":"page"},{"location":"man/interop/#Generated-IR-functions","page":"Julia integration","title":"Generated IR functions","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"With generated functions, it is possible to manually generate Julia IR when a function is visited by the Julia compiler. LLVM.jl extends this with the ability to define functions that generate LLVM IR; which is very useful to generate code that is not easily expressible in Julia:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"@generated function add(x::T, y::T) where {T}\n  @dispose ctx=Context() begin\n    # get the element type\n    eltyp = convert(LLVMType, T)\n\n    # create a function\n    paramtyps = [eltyp, eltyp]\n    f, ft = create_function(eltyp, paramtyps)\n\n    # generate IR\n    @dispose builder=IRBuilder() begin\n      entry = BasicBlock(f, \"entry\")\n      position!(builder, entry)\n\n      val = add!(builder, parameters(f)[1], parameters(f)[2])\n\n      ret!(builder, val)\n    end\n\n    call_function(f, T, Tuple{T, T}, :x, :y)\n  end\nend\n\n@code_llvm debuginfo=:none add(1, 2)\n\nadd(1,2)\n\n# output\n\n; Function Signature: add(Int64, Int64)\ndefine i64 @julia_add_3944(i64 signext %\"x::Int64\", i64 signext %\"y::Int64\") #0 {\ntop:\n  %0 = add i64 %\"y::Int64\", %\"x::Int64\"\n  ret i64 %0\n}\n3","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"The call_function is where the magic happens: it generates LLVM IR for the function that's being called, and embeds it in the generated Julia IR so that it can be processed by the Julia compiler.","category":"page"},{"location":"man/interop/#Inline-assembly","page":"Julia integration","title":"Inline assembly","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"An extension of this mechanism is the @asmcall macro, which allows embedding inline assembly in Julia functions:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> add(x::Int, y::Int) = @asmcall(\"add \\$0, \\$1, \\$2\", \"=r,r,r\",\n                                      Int64, Tuple{Int64,Int64},\n                                      x, y);\n\njulia> add(1,2)\n3\n\njulia> @code_native add(1,2)\n\t; InlineAsm Start\n\tadd\tx0, x0, x1\n\t; InlineAsm End\n\tret","category":"page"},{"location":"man/interop/#LLVM-pointers","page":"Julia integration","title":"LLVM pointers","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"Julia's pointer type Ptr only keeps track of the element type, and not the address space. Julia has Core.LLVMPtr to track address space information, with the necessary codegen support, but no utility functions. LLVM.jl provides the functionality that's commonly needed when working with pointers:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"pointerref: get the value of memory, at a specific index, with specific alignment\npointerset: set the value of memory, at a specific index, with specific alignment\nunsafe_load and unsafe_store!: higher-level versions of these functions\nbasic pointer arithmetic: conversions to/from integers, addition, subtraction, comparison, etc.\naddrspacecast: convert between pointers with different address spaces","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> a = [1];\n\njulia> ptr = Core.LLVMPtr{Int,0}(pointer(a));\n\njulia> unsafe_load(ptr)\n1\n\njulia> unsafe_store!(ptr, 42)\n\njulia> a\n1-element Vector{Int64}:\n 42","category":"page"},{"location":"man/interop/#Intrinsics","page":"Julia integration","title":"Intrinsics","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.jl also provides Julia functions for common intrinsics, allowing them to be used in regular Julia code. For example, the assume function can be used to emit llvm.assume intrinsic calls:","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> max(a, b) = a < b ? b : a;\n\njulia> @code_llvm debuginfo=:none max(1,2)\n; Function Signature: max(Int64, Int64)\ndefine i64 @julia_max_22435(i64 signext %\"a::Int64\", i64 signext %\"b::Int64\") #0 {\ntop:\n  %\"a::Int64.b::Int64\" = call i64 @llvm.smax.i64(i64 %\"a::Int64\", i64 %\"b::Int64\")\n  ret i64 %\"a::Int64.b::Int64\"\n}\n\njulia> function max(a, b)\n         assume(a > b)\n         a < b ? b : a\n       end;\n\njulia> @code_llvm debuginfo=:none max(1,2)\n; Function Signature: max(Int64, Int64)\ndefine i64 @julia_max_22441(i64 signext %\"a::Int64\", i64 signext %\"b::Int64\") #0 {\ntop:\n  %0 = icmp slt i64 %\"b::Int64\", %\"a::Int64\"\n  call void @llvm.assume(i1 %0)\n  ret i64 %\"a::Int64\"\n}","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"To abort execution, the trap() function can be used, generating a call to @llvm.trap.","category":"page"},{"location":"man/interop/#Optimization-passes","page":"Julia integration","title":"Optimization passes","text":"","category":"section"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"Julia's LLVM passes are usable in the same way as LLVM's passes, and are automatically available to any PassBuilder. Similarly, the default Julia optimization pipeline can be used through the JuliaPipeline pipeline object.","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"julia> run!(JuliaPipeline(), mod)","category":"page"},{"location":"man/interop/","page":"Julia integration","title":"Julia integration","text":"This object supports many keyword arguments to configure the pipeline; refer to the API documentation for more information.","category":"page"},{"location":"man/modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"LLVM modules are the main container of LLVM IR code. They are created using the Module constructor (not exported because of the name conflict with Base.Module):","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> mod = LLVM.Module(\"SomeModule\")\n; ModuleID = 'SomeModule'\nsource_filename = \"SomeModule\"","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"The only argument to the constructor is the module's name. Along with some other properties, this can be read and modified using dedicated functions:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"name/name!: module name\ntriple/triple!: target triple string\ndatalayout/datalayout!: a data layout string or DataLayout object\ninline_asm/inline_asm!: module-level inline assembly\nsdk_version/sdk_version!: Apple SDK version\nset_used! and set_compiler_used!: to set @llvm.used and @llvm.compiler.used","category":"page"},{"location":"man/modules/#Textual-representation","page":"Modules","title":"Textual representation","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"In the REPL, LLVM modules are displayed verbosely, i.e., they print their IR code. Simply printing the module object will instead output a compact object representation, so if you want to debug your application by printing IR you need to invoke the display function or explicitly stringify the object:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> print(mod)\nLLVM.Module(\"SomeModule\")\n\njulia> show(stdout, \"text/plain\", mod)  # equivalent of `display`\n; ModuleID = 'SomeModule'\nsource_filename = \"SomeModule\"\n\njulia> @info \"My module:\\n\" * string(mod)\n┌ Info: My module:\n│ ; ModuleID = 'SomeModule'\n└ source_filename = \"SomeModule\"","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"To parse an LLVM module from a textual string, simply use the parse function:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> ir = \"\"\"\n         define i64 @\"add\"(i64 %0, i64 %1) {\n         top:\n           %2 = add i64 %1, %0\n           ret i64 %2\n         }\"\"\";\n\njulia> parse(LLVM.Module, ir)\ndefine i64 @add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}","category":"page"},{"location":"man/modules/#Binary-representation-(\"bitcode\")","page":"Modules","title":"Binary representation (\"bitcode\")","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"If you need the binary bitcode, you can convert the module to a vector of bytes, or write it to an I/O stream:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> # only showing the first two bytes, for brevity\n       convert(Vector{UInt8}, mod)[1:2]\n2-element Vector{UInt8}:\n 0x42\n 0x43\n\njulia> sprint(write, mod)[1:2]\n\"BC\"","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Parsing bitcode is again done with the parse function, dispatching on the fact that the bitcode is represented as a vector of bytes:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> bc = UInt8[0x42, 0x43, ...]\n\njulia> parse(LLVM.Module, bc)\nsource_filename = \"SomeModule\"","category":"page"},{"location":"man/modules/#Contents","page":"Modules","title":"Contents","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"To iterate the contents of a module, several iterators are provided (with different levels of functionality, based on what the LLVM C API provides).","category":"page"},{"location":"man/modules/#Global-objects","page":"Modules","title":"Global objects","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Globals, such as global variables, can be iterated with the globals function:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> gv = GlobalVariable(mod, LLVM.Int32Type(), \"SomeGlobal\");\n\njulia> collect(globals(mod))\n1-element Vector{GlobalVariable}:\n @SomeGlobal = external global i32","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"In addition to the iteration interface, it is possible to move from one global to the previous or next one using respectively the prevglobal and nextglobal functions.","category":"page"},{"location":"man/modules/#Functions","page":"Modules","title":"Functions","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Functions can be iterated with the functions function:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> fun = LLVM.Function(mod, \"SomeFunction\", LLVM.FunctionType(LLVM.VoidType()));\n\njulia> collect(functions(mod))\n1-element Vector{LLVM.Function}:\n declare void @SomeFunction()","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Again, it is possible to move from one function to the previous or next one using respectively the prevfun and nextfun functions.","category":"page"},{"location":"man/modules/#Flags","page":"Modules","title":"Flags","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Modules can also have flags associated with them, which can be set and retrieved using the associative iterator returned by the flags function:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> flags(mod)[\"SomeFlag\", LLVM.API.LLVMModuleFlagBehaviorError] = Metadata(ConstantInt(42))\ni64 42\n\njulia> mod\n; ModuleID = 'SomeModule'\nsource_filename = \"SomeModule\"\n\n!llvm.module.flags = !{!0}\n\n!0 = !{i32 1, !\"SomeFlag\", i64 42}","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Note the additional argument to setindex!, which indicates the flag behavior.","category":"page"},{"location":"man/modules/#Linking","page":"Modules","title":"Linking","text":"","category":"section"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"Modules can be linked together using the link! function. This function takes two modules, destroying the source module in the process:","category":"page"},{"location":"man/modules/","page":"Modules","title":"Modules","text":"julia> src = parse(LLVM.Module, \"define void @foo() { ret void }\");\n\njulia> dst = parse(LLVM.Module, \"define void @bar() { ret void }\");\n\njulia> link!(dst, src)\n\njulia> dst\ndefine void @bar() {\n  ret void\n}\n\ndefine void @foo() {\n  ret void\n}","category":"page"},{"location":"man/codegen/#Code-generation","page":"Code generation","title":"Code generation","text":"","category":"section"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"To generate native code from an LLVM module, you need to create a target, a target machine, and use those objects to call the emit function to generate machine code.","category":"page"},{"location":"man/codegen/#Targets","page":"Code generation","title":"Targets","text":"","category":"section"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"In LLVM, targets represent a specific architecture, such as x86_64, or aarch64. You can inspect the available targets using the targets function:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> collect(targets())\n5-element Vector{Target}:\n LLVM.Target(aarch64_32): AArch64 (little endian ILP32)\n LLVM.Target(aarch64_be): AArch64 (big endian)\n LLVM.Target(aarch64): AArch64 (little endian)\n LLVM.Target(arm64_32): ARM64 (little endian ILP32)\n LLVM.Target(arm64): ARM64 (little endian)","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"The exact availability of targets depends on the LLVM build, and what target infos have been activated. Additional targets can be activated using Initialize*TargetInfo functions:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> LLVM.InitializeWebAssemblyTargetInfo()\n\njulia> # or, to simply initialize all target infos\n       LLVM.InitializeAllTargetInfos()","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"Alternatively, targets can also be constructed by name or by triple (again, assuming the necessary bits in LLVM have been initialized):","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> target = Target(; name=\"wasm64\")\nLLVM.Target(wasm64): WebAssembly 64-bit\n\njulia> triple = \"wasm64-unknown-unknown\";\n\njulia> target = Target(; triple)\nLLVM.Target(wasm64): WebAssembly 64-bit","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"With these objects, a number of APIs are available:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"name: the target's name\ndescription: a textual description of the target\nhasjit: whether the target has a JIT\nhastargetmachine: whether the target has a target machine\nhasasmparser: whether the target has an assembly parser","category":"page"},{"location":"man/codegen/#Target-machines","page":"Code generation","title":"Target machines","text":"","category":"section"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"Starting from a target and a triple, it's possible to create a target machine for native code generation purposes. Note that this requires initializing both the target and its machine code generation support:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> LLVM.InitializeWebAssemblyTarget();\n\njulia> LLVM.InitializeWebAssemblyTargetMC();\n\njulia> tm = TargetMachine(target, triple);","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"The target machine constructor takes various additional options too:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"cpu and features: strings that describe the CPU and its features to target\noptlevel: the optimization level to use\nreloc: the relocation model to use\ncode: the code model to use","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"Various APIs are available to manipulate TargetMachine objects:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"target and triple: the target and triple that was used to create the target machine\ncpu and features: the CPU and features string that were (optionally) set\nasm_verbosity!: enable or disable verbose assembly emission","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"The most important function however is the emit function, which converts an IR module to native code:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> LLVM.InitializeWebAssemblyAsmPrinter()\n\njulia> String(emit(tm, mod, LLVM.API.LLVMAssemblyFile)) |> println\n\t.text\n\t.file\t\"SomeModule\"\n\t.section\t.custom_section.target_features,\"\",@\n\t.int8\t3\n\t.int8\t43\n\t.int8\t15\n\t.ascii\t\"mutable-globals\"\n\t.int8\t43\n\t.int8\t8\n\t.ascii\t\"sign-ext\"\n\t.int8\t43\n\t.int8\t8\n\t.ascii\t\"memory64\"\n\t.text","category":"page"},{"location":"man/codegen/#Data-layout","page":"Code generation","title":"Data layout","text":"","category":"section"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"Data layouts are used to describe the memory layout for a given target. It's the responsibility of the frontend to generate IR that matches the target's data layout. This involves both configuring the module with the correct data layout string, but also generating operations that are valid for the target's memory model.","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"To create a data layout object, you call the DataLayout constructor, either specifying the data layout string directly, or by inferring it from a target machine","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> DataLayout(tm)\nDataLayout(e-m:e-p:64:64-p10:8:8-p20:8:8-i64:64-n32:64-S128-ni:1:10:20)\n\njulia> dl = DataLayout(\"e-m:e-p:64:64-i64:64-n32:64-S128\");","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"An IR module can now be configured with this data layout:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"julia> datalayout!(mod, dl);\n\njulia> mod\n; ModuleID = 'SomeModule'\nsource_filename = \"SomeModule\"\ntarget datalayout = \"e-m:e-p:64:64-i64:64-n32:64-S128\"\n\n!llvm.module.flags = !{!0, !1}\n\n!0 = !{i32 1, !\"wasm-feature-mutable-globals\", i32 43}\n!1 = !{i32 1, !\"wasm-feature-sign-ext\", i32 43}","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"The data layout object can be used to query various properties that are relevant for generating IR:","category":"page"},{"location":"man/codegen/","page":"Code generation","title":"Code generation","text":"byteorder\npointersize\nintptr\nsizeof\nstorage_size\nabi_alignment\nframe_alignment\npreferred_alignment\nelement_at\noffsetof","category":"page"},{"location":"lib/codegen/#Code-generation","page":"Code generation","title":"Code generation","text":"","category":"section"},{"location":"lib/codegen/#Targets","page":"Code generation","title":"Targets","text":"","category":"section"},{"location":"lib/codegen/","page":"Code generation","title":"Code generation","text":"Target\nname(::Target)\ndescription(::Target)\nhasjit(::Target)\nhastargetmachine(::Target)\nhasasmparser(::Target)\ntargets","category":"page"},{"location":"lib/codegen/#LLVM.Target","page":"Code generation","title":"LLVM.Target","text":"Target\n\nA structure exposing target-specific information.\n\n\n\n\n\n","category":"type"},{"location":"lib/codegen/#LLVM.name-Tuple{Target}","page":"Code generation","title":"LLVM.name","text":"name(target::Target)\n\nGet the name of the given target.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.description-Tuple{Target}","page":"Code generation","title":"LLVM.description","text":"description(target::Target)\n\nGet a short description of the given target.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.hasjit-Tuple{Target}","page":"Code generation","title":"LLVM.hasjit","text":"hasjit(target::Target)\n\nCheck if this targets supports the just-in-time compilation.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.hastargetmachine-Tuple{Target}","page":"Code generation","title":"LLVM.hastargetmachine","text":"hastargetmachine(target::Target)\n\nCheck if this target supports code generation.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.hasasmparser-Tuple{Target}","page":"Code generation","title":"LLVM.hasasmparser","text":"hasasmparser(target::Target)\n\nCheck if this target supports assembly parsing.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.targets","page":"Code generation","title":"LLVM.targets","text":"targets()\n\nGet an iterator over the available targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#Target-machines","page":"Code generation","title":"Target machines","text":"","category":"section"},{"location":"lib/codegen/","page":"Code generation","title":"Code generation","text":"TargetMachine\ndispose(::TargetMachine)\ntarget(::TargetMachine)\ntriple(::TargetMachine)\ntriple()\nnormalize(::String)\ncpu(::TargetMachine)\nfeatures(::TargetMachine)\nasm_verbosity!\nemit\nadd_transform_info!\nadd_library_info!\nJITTargetMachine","category":"page"},{"location":"lib/codegen/#LLVM.TargetMachine","page":"Code generation","title":"LLVM.TargetMachine","text":"TargetMachine\n\nPrimary interface to the complete machine description for the target machine.\n\nAll target-specific information should be accessible through this interface.\n\n\n\n\n\n","category":"type"},{"location":"lib/codegen/#LLVM.dispose-Tuple{TargetMachine}","page":"Code generation","title":"LLVM.dispose","text":"dispose(tm::TargetMachine)\n\nDispose of the given target machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.target-Tuple{TargetMachine}","page":"Code generation","title":"LLVM.target","text":"target(tm::TargetMachine)\n\nGet the target of the given target machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.triple-Tuple{TargetMachine}","page":"Code generation","title":"LLVM.triple","text":"triple(tm::TargetMachine)\n\nGet the triple of the given target machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.triple-Tuple{}","page":"Code generation","title":"LLVM.triple","text":"triple()\n\nGet the default target triple.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.normalize-Tuple{String}","page":"Code generation","title":"LLVM.normalize","text":"normalize(triple::String)\n\nNormalize the given target triple.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.cpu-Tuple{TargetMachine}","page":"Code generation","title":"LLVM.cpu","text":"cpu(tm::TargetMachine)\n\nGet the CPU of the given target machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.features-Tuple{TargetMachine}","page":"Code generation","title":"LLVM.features","text":"features(tm::TargetMachine)\n\nGet the feature string of the given target machine.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.asm_verbosity!","page":"Code generation","title":"LLVM.asm_verbosity!","text":"asm_verbosity!(tm::TargetMachine, verbose::Bool)\n\nSet the verbosity of the target machine's assembly output.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.emit","page":"Code generation","title":"LLVM.emit","text":"emit(tm::TargetMachine, mod::Module, filetype::LLVMCodeGenFileType) -> UInt8[]\n\nGenerate code for the given module using the target machine, returning the binary data. If assembly code was requested, the binary data can be converted back using String.\n\n\n\n\n\nemit(tm::TargetMachine, mod::Module, filetype::LLVMCodeGenFileType, path::String)\n\nGenerate code for the given module using the target machine, writing it to the given file.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.add_transform_info!","page":"Code generation","title":"LLVM.add_transform_info!","text":"add_transform_info!(pm::PassManager, [tm::TargetMachine])\n\nAdd target-specific analysis passes to the given pass manager.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.add_library_info!","page":"Code generation","title":"LLVM.add_library_info!","text":"add_library_info!(pm::PassManager, triple::String)\n\nAdd target-specific library information to the given pass manager.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.JITTargetMachine","page":"Code generation","title":"LLVM.JITTargetMachine","text":"JITTargetMachine(; triple=LLVM.triple(), cpu=\"\", features=\"\",\n                 optlevel=API.LLVMCodeGenLevelDefault)\n\nCreate a target machine suitable for JIT compilation with the ORC JIT.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#Data-layout","page":"Code generation","title":"Data layout","text":"","category":"section"},{"location":"lib/codegen/","page":"Code generation","title":"Code generation","text":"DataLayout\ndispose(::DataLayout)\nbyteorder\npointersize\nintptr\nsizeof(::DataLayout, ::LLVMType)\nstorage_size\nabi_size\nabi_alignment\nframe_alignment\npreferred_alignment\nelement_at\noffsetof","category":"page"},{"location":"lib/codegen/#LLVM.DataLayout","page":"Code generation","title":"LLVM.DataLayout","text":"DataLayout\n\nA parsed version of the target data layout string in and methods for querying it.\n\nThe target data layout string is specified by the target - a frontend generating LLVM IR is required to generate the right target data for the target being codegen'd to.\n\n\n\n\n\n","category":"type"},{"location":"lib/codegen/#LLVM.dispose-Tuple{DataLayout}","page":"Code generation","title":"LLVM.dispose","text":"dispose(data::DataLayout)\n\nDispose of the given target data layout.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.byteorder","page":"Code generation","title":"LLVM.byteorder","text":"byteorder(data::DataLayout)\n\nGet the byte order of the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.pointersize","page":"Code generation","title":"LLVM.pointersize","text":"pointersize(data::DataLayout, [addrspace::Integer])\n\nGet the pointer size of the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.intptr","page":"Code generation","title":"LLVM.intptr","text":"intptr(data::DataLayout, [addrspace::Integer])\n\nGet the integer type that is the same size as a pointer for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#Base.sizeof-Tuple{DataLayout, LLVMType}","page":"Code generation","title":"Base.sizeof","text":"sizeof(data::DataLayout, typ::LLVMType)\n\nGet the size of the given type in bytes for the target data layout.\n\n\n\n\n\n","category":"method"},{"location":"lib/codegen/#LLVM.storage_size","page":"Code generation","title":"LLVM.storage_size","text":"storage_size(data::DataLayout, typ::LLVMType)\n\nGet the storage size of the given type in bytes for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.abi_size","page":"Code generation","title":"LLVM.abi_size","text":"abi_size(data::DataLayout, typ::LLVMType)\n\nGet the ABI size of the given type in bytes for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.abi_alignment","page":"Code generation","title":"LLVM.abi_alignment","text":"abi_alignment(data::DataLayout, typ::LLVMType)\n\nGet the ABI alignment of the given type in bytes for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.frame_alignment","page":"Code generation","title":"LLVM.frame_alignment","text":"frame_alignment(data::DataLayout, typ::LLVMType)\n\nGet the call frame alignment of the given type in bytes for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.preferred_alignment","page":"Code generation","title":"LLVM.preferred_alignment","text":"preferred_alignment(data::DataLayout, typ::LLVMType)\npreferred_alignment(data::DataLayout, var::GlobalVariable)\n\nGet the preferred alignment of the given type or global variable in bytes for the target data layout.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.element_at","page":"Code generation","title":"LLVM.element_at","text":"element_at(data::DataLayout, typ::StructType, offset::Integer)\n\nGet the element at the given offset in a struct type for the target data layout.\n\nSee also: offsetof.\n\n\n\n\n\n","category":"function"},{"location":"lib/codegen/#LLVM.offsetof","page":"Code generation","title":"LLVM.offsetof","text":"offsetof(data::DataLayout, typ::StructType, element::Integer)\n\nGet the offset of the given element in a struct type for the target data layout.\n\nSee also: element_at.\n\n\n\n\n\n","category":"function"},{"location":"lib/analyses/#Analyses","page":"Analyses","title":"Analyses","text":"","category":"section"},{"location":"lib/analyses/#IR-verification","page":"Analyses","title":"IR verification","text":"","category":"section"},{"location":"lib/analyses/","page":"Analyses","title":"Analyses","text":"verify","category":"page"},{"location":"lib/analyses/#LLVM.verify","page":"Analyses","title":"LLVM.verify","text":"verify(mod::Module)\nverify(f::Function)\n\nVerify the module or function mod or f. If verification fails, an exception is thrown.\n\n\n\n\n\n","category":"function"},{"location":"lib/analyses/#Dominator-and-post-dominator","page":"Analyses","title":"Dominator and post-dominator","text":"","category":"section"},{"location":"lib/analyses/","page":"Analyses","title":"Analyses","text":"DomTree\ndispose(::DomTree)\nPostDomTree\ndispose(::PostDomTree)\ndominates","category":"page"},{"location":"lib/analyses/#LLVM.DomTree","page":"Analyses","title":"LLVM.DomTree","text":"DomTree\n\nDominator tree for a function.\n\n\n\n\n\n","category":"type"},{"location":"lib/analyses/#LLVM.dispose-Tuple{DomTree}","page":"Analyses","title":"LLVM.dispose","text":"dispose(::DomTree)\n\nDispose of a dominator tree.\n\n\n\n\n\n","category":"method"},{"location":"lib/analyses/#LLVM.PostDomTree","page":"Analyses","title":"LLVM.PostDomTree","text":"PostDomTree\n\nPost-dominator tree for a function.\n\n\n\n\n\n","category":"type"},{"location":"lib/analyses/#LLVM.dispose-Tuple{PostDomTree}","page":"Analyses","title":"LLVM.dispose","text":"dispose(tree::PostDomTree)\n\nDispose of a post-dominator tree.\n\n\n\n\n\n","category":"method"},{"location":"lib/analyses/#LLVM.dominates","page":"Analyses","title":"LLVM.dominates","text":"dominates(tree::DomTree, A::Instruction, B::Instruction)\ndominates(tree::PostDomTree, A::Instruction, B::Instruction)\n\nCheck if instruction A dominates instruction B in the dominator tree tree.\n\n\n\n\n\n","category":"function"},{"location":"man/essentials/#Essentials","page":"Essentials","title":"Essentials","text":"","category":"section"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"DocTestSetup = quote\n    using LLVM\nend","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"After importing LLVM.jl, the packages is ready to use. A simple test to check if the package is working correctly is to query the version of the LLVM library:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> LLVM.version()\nv\"15.0.7\"","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Some back-end functionality may require explicit initialization, for which there are specific functions (replacing * with the back-end name):","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"LLVM.Initialize*AsmParser: initialize the assembly parser;\nLLVM.Initialize*AsmPrinter: initialize the assembly printer;\nLLVM.Initialize*Disassembler: initialize the disassembler;\nLLVM.Initialize*TargetInfo: initialize the target, allowing inspection;\nLLVM.Initialize*Target: initialize the target, allowing use;\nLLVM.Initialize*TargetMC: initialize the target machine code generation.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"These functions are only available for the back-ends that are enabled in the LLVM library:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> LLVM.backends()\n4-element Vector{Symbol}:\n :AArch64\n :AVR\n :BPF\n :WebAssembly","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Special versions of these functions are available to initialize all available targets, e.g., LLVM.InitializeAllTargetInfos, or to initialize the native target, e.g., LLVM.InitializeNativeTarget.","category":"page"},{"location":"man/essentials/#Contexts","page":"Essentials","title":"Contexts","text":"","category":"section"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"DocTestSetup = quote\n    using LLVM\n\n    # XXX: clean-up previous contexts\n    while context(; throw_error=false) !== nothing\n        dispose(context())\n    end\nend","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Most operations in LLVM require a context to be active. In LLVM.jl, LLVM contexts are available as Context objects, and you are expected to create a context before creating any other LLVM objects.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"To create a new LLVM context, use the Context() constructor:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> ctx = Context()\nLLVM.Context(0x0000600003d18980, typed ptrs)\n\njulia> dispose(ctx) # see next section","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Although many LLVM APIs expect a context as an argument, LLVM.jl automatically manages the context in the task-local state. The current task-local context is accessible via the context() function, and is automatically used by most LLVM.jl functions when an API requires an LLVM context. To populate the task-local context, it is sufficient to create a new context object:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> context()\nERROR: No LLVM context is active\n\njulia> ctx = Context();\n\njulia> context()\nLLVM.Context(0x0000600000ae1470, typed ptrs)","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Although the context is automatically managed by LLVM.jl, it is still important to keep track of the context object for proper disposal after use. This also wipes the task-local context:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> ctx = Context()\nLLVM.Context(0x000060000007c4b0, typed ptrs)\n\njulia> dispose(ctx)\n\njulia> context()\nERROR: No LLVM context is active","category":"page"},{"location":"man/essentials/#Memory-management","page":"Essentials","title":"Memory management","text":"","category":"section"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"LLVM.jl does not use automatic memory management for LLVM objects[1], and instead relies on manual disposal of resources by calling the dispose method. For example, to create and dispose of a module object:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"[1]: See this issue for more details.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> mod = LLVM.Module(\"MyModule\");\n\njulia> dispose(mod)","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"After calling dispose, the object is no longer valid and should not be used. Doing so will often result in hard crashes:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> mod\n[94707] signal (11.2): Segmentation fault: 11","category":"page"},{"location":"man/essentials/#Scoped-disposal","page":"Essentials","title":"Scoped disposal","text":"","category":"section"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"For convenience, many of these objects can be created and disposed using do-block variants of their constructors. This makes it harder to use the object outside of its lifetime, and also handles exceptions that might occur during the object's construction:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> LLVM.Module(\"MyModule\") do mod\n         # use mod\n       end","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"This pattern is useful, but can become cumbersome when working with multiple objects that need to be disposed of. In addition, the function closures constructed here can have an impact on performance. To address these issues, LLVM.jl provides a @dispose macro that conveniently disposes of multiple objects at once:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> @dispose ctx=Context() mod=LLVM.Module(\"jit\") begin\n         # mod and ctx are automatically disposed of after this block\n       end","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"It is recommended to use the @dispose macro whenever possible.","category":"page"},{"location":"man/essentials/#Debugging-missing-disposals","page":"Essentials","title":"Debugging missing disposals","text":"","category":"section"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"To ensure that all resources are properly disposed of, LLVM.jl provides functionality to track the creation and disposal of objects. This can be enabled by setting the memcheck preference in LocalPreferences to true.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"When enabled, LLVM.jl will warn when using an object after it has been disposed of:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> ctx = Context();\n\njulia> dispose(ctx)\n\njulia> ctx\nWARNING: An instance of Context is being used after it was disposed.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"The package will also warn about erroneous disposals, whether it's disposing an unknown object, or disposing an object that has already been disposed of:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> buf = MemoryBuffer(UInt8[]);\n\njulia> dispose(buf)\njulia> dispose(buf)\nWARNING: An instance of MemoryBuffer is being disposed twice.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> dispose(MemoryBuffer(LLVM.API.LLVMMemoryBufferRef(1)))\nWARNING: An unknown instance of MemoryBuffer is being disposed of.","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"Finally, when not properly disposing of an object, LLVM.jl will warn about the leaked object when the process exits:","category":"page"},{"location":"man/essentials/","page":"Essentials","title":"Essentials","text":"julia> ctx = Context();\n\njulia> exit()\nWARNING: An instance of Context was not properly disposed of.","category":"page"},{"location":"man/execution/#Execution","page":"Execution","title":"Execution","text":"","category":"section"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n      define i64 @\"add\"(i64 %0, i64 %1) {\n      top:\n        %2 = add i64 %1, %0\n        ret i64 %2\n      }\"\"\"\n    mod = parse(LLVM.Module, ir)\n    add = only(functions(mod))\nend","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"If instead of compiling the LLVM module to native code, you just want to execute it, LLVM offers different mechanisms to do so. We'll be using the following LLVM IR code for the examples in this section:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> add\ndefine i64 @add(i64 %0, i64 %1) {\ntop:\n  %2 = add i64 %1, %0\n  ret i64 %2\n}","category":"page"},{"location":"man/execution/#Interpreter","page":"Execution","title":"Interpreter","text":"","category":"section"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"LLVM's interpreter is a simple way to execute LLVM IR code, and can be constructed from just a module. Executing code is done using the run function, which takes a reference to the function to execute, and an array of GenericValue arguments, returning a GenericValue result:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> engine = Interpreter(mod);\n\njulia> res = run(engine, add, [GenericValue(LLVM.Int64Type(), 1),\n                               GenericValue(LLVM.Int64Type(), 2)]);\n\njulia> convert(Int, res)\n3","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"After having constructed an engine, more modules can be added to it using push!, and removed from it using delete!.","category":"page"},{"location":"man/execution/#MCJIT","page":"Execution","title":"MCJIT","text":"","category":"section"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"Interpreting IR is obviously slow, so for all but the simplest programs you'll want to use the JIT engine instead, which is based on LLVM's MCJIT. Usage of the JIT engine is almost identical to the interpreter, using JIT objects instead.","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"One crucial difference is that MCJIT does not support the run function with arguments. Instead, you need to look up the address of the compiled function, and call it directly:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> engine = JIT(mod);\n\njulia> addr = lookup(engine, \"add\");\n\njulia> res = ccall(addr, Int64, (Int64, Int64), 1, 2)\n3","category":"page"},{"location":"man/execution/#ORCJIT","page":"Execution","title":"ORCJIT","text":"","category":"section"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"The ORCJIT engine is a more modern JIT engine, which is more flexible and powerful than MCJIT. LLVM.jl only supports the ORCv2 API, which is the latest version of ORCJIT.","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"warning: Warning\nDocumentation for ORCJIT is a work in progress.","category":"page"},{"location":"man/execution/#Thread-safe-operation","page":"Execution","title":"Thread-safe operation","text":"","category":"section"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"DocTestSetup = quote\n    using LLVM\n\n    # XXX: clean-up previous contexts\n    while ts_context(; throw_error=false) !== nothing\n        dispose(ts_context())\n    end\nend","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"Because of ORC often compiling code lazily, thread-safety is a concern. To ensure that everything is thread-safe, the ORC APIs use thread-safe wrappers of LLVM objects like contexts and modules.","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"Thread safe contexts are similar to regular contexts, but they require taking a lock when using them. On the Julia side, they are created much like regular contexts:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> ts_ctx = ThreadSafeContext()\nThreadSafeContext(Ptr{LLVM.API.LLVMOrcOpaqueThreadSafeContext} @0x00006000035fb8a0)\n\njulia> dispose(ts_ctx)","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"LLVM.jl also maintains a task-bound thread-safe context, simplifying API usage much in the same way as regular contexts:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> ts_context()\nERROR: No LLVM thread-safe context is active\n\njulia> ts_ctx = ThreadSafeContext();\n\njulia> ts_context()\nThreadSafeContext(Ptr{LLVM.API.LLVMOrcOpaqueThreadSafeContext} @0x00006000035844a0)\n\njulia> dispose(ts_ctx)\n\njulia> ts_context()\nERROR: No LLVM thread-safe context is active","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"DocTestSetup = quote\n    using LLVM\n\n    if ts_context(; throw_error=false) === nothing\n        ThreadSafeContext()\n    end\nend","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"Similarly, ThreadSafeModule is a thread-safe wrapper around a module, and can be used much like a regular module:","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> ts_mod = ThreadSafeModule(\"SomeModule\")\nThreadSafeModule(Ptr{LLVM.API.LLVMOrcOpaqueThreadSafeModule} @0x00006000037fb640)\n\njulia> dispose(ts_mod)","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"Whereas thread-safe contexts are just for use with LLVM C APIs, it is possible to access the underlying module from a thread-safe module (taking a lock in the process):","category":"page"},{"location":"man/execution/","page":"Execution","title":"Execution","text":"julia> ts_mod = ThreadSafeModule(\"SomeModule\");\n\njulia> ts_mod() do mod\n            string(mod)\n        end\n\"; ModuleID = 'SomeModule'\\nsource_filename = \\\"SomeModule\\\"\\n\"","category":"page"},{"location":"lib/modules/#Modules","page":"Modules","title":"Modules","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"LLVM.Module\ncopy(::LLVM.Module)\ndispose(::LLVM.Module)","category":"page"},{"location":"lib/modules/#LLVM.Module","page":"Modules","title":"LLVM.Module","text":"LLVM.Module\n\nModules are the top level container of all other LLVM IR objects. Each module directly contains a list of globals variables, a list of functions, a list of libraries (or other modules) this module depends on, a symbol table, and various data about the target's characteristics.\n\n\n\n\n\n","category":"type"},{"location":"lib/modules/#Base.copy-Tuple{LLVM.Module}","page":"Modules","title":"Base.copy","text":"copy(mod::LLVM.Module)\n\nClone the given module.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.dispose-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.dispose","text":"dispose(mod::LLVM.Module)\n\nDispose of the given module, releasing all resources associated with it. The module should not be used after this operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Properties-and-operations","page":"Modules","title":"Properties and operations","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"context(::LLVM.Module)\nname(::LLVM.Module)\nname!(::LLVM.Module, ::String)\ntriple(::LLVM.Module)\ntriple!(::LLVM.Module, ::String)\ndatalayout\ndatalayout!\ninline_asm!\ninline_asm\nsdk_version\nsdk_version!\nset_used!\nset_compiler_used!","category":"page"},{"location":"lib/modules/#LLVM.context-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.context","text":"context(mod::LLVM.Module)\n\nGet the context in which the given module was created.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.name-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.name","text":"name(mod::LLVM.Module)\n\nGet the name of the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.name!-Tuple{LLVM.Module, String}","page":"Modules","title":"LLVM.name!","text":"name!(mod::LLVM.Module, name::String)\n\nSet the name of the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.triple-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.triple","text":"triple(mod::LLVM.Module)\n\nGet the target triple of the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.triple!-Tuple{LLVM.Module, String}","page":"Modules","title":"LLVM.triple!","text":"triple!(mod::LLVM.Module, triple::String)\n\nSet the target triple of the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.datalayout","page":"Modules","title":"LLVM.datalayout","text":"datalayout(mod::LLVM.Module)\n\nGet the data layout of the given module.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.datalayout!","page":"Modules","title":"LLVM.datalayout!","text":"datalayout!(mod::LLVM.Module, layout)\n\nSet the data layout of the given module. The layout can be a string or a DataLayout object.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.inline_asm!","page":"Modules","title":"LLVM.inline_asm!","text":"inline_asm!(mod::LLVM.Module, asm::String; overwrite::Bool=false)\n\nAdd module-level inline assembly to the given module. If overwrite is true, the existing inline assembly is replaced, otherwise the new assembly is appended.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.inline_asm","page":"Modules","title":"LLVM.inline_asm","text":"inline_asm(mod::LLVM.Module) -> String\n\nGet the module-level inline assembly of the given module.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.sdk_version","page":"Modules","title":"LLVM.sdk_version","text":"sdk_version!(mod::LLVM.Module, version::VersionNumber)\n\nSet the SDK version of the given module.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.sdk_version!","page":"Modules","title":"LLVM.sdk_version!","text":"sdk_version(mod::LLVM.Module)\n\nGet the SDK version of the given module, if it has been set.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.set_used!","page":"Modules","title":"LLVM.set_used!","text":"set_used!(mod::LLVM.Module, values::GlobalVariable...)\n\nMark the given global variables as used in the given module by appending them to the llvm.used metadata node.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.set_compiler_used!","page":"Modules","title":"LLVM.set_compiler_used!","text":"set_compiler_used!(mod::LLVM.Module, values::GlobalVariable...)\n\nMark the given global variables as used by the compiler in the given module by appending them to the llvm.compiler.used metadata node. As opposed to set_used!, this still allows the linker to remove the variable if it is not actually used.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#Textual-representation","page":"Modules","title":"Textual representation","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"parse(::Type{LLVM.Module}, ir::String)\nstring(mod::LLVM.Module)","category":"page"},{"location":"lib/modules/#Base.parse-Tuple{Type{LLVM.Module}, String}","page":"Modules","title":"Base.parse","text":"parse(::Type{Module}, ir::String)\n\nParse the given LLVM IR string into a module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Base.string-Tuple{LLVM.Module}","page":"Modules","title":"Base.string","text":"string(mod::Module)\n\nConvert the given module to a string.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Binary-representation-(\"bitcode\")","page":"Modules","title":"Binary representation (\"bitcode\")","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"parse(::Type{LLVM.Module}, membuf::MemoryBuffer)\nparse(::Type{LLVM.Module}, data::Vector)\nconvert(::Type{MemoryBuffer}, mod::LLVM.Module)\nconvert(::Type{Vector{T}}, mod::LLVM.Module) where {T<:Union{UInt8,Int8}}\nwrite(io::IO, mod::LLVM.Module)","category":"page"},{"location":"lib/modules/#Base.parse-Tuple{Type{LLVM.Module}, MemoryBuffer}","page":"Modules","title":"Base.parse","text":"parse(::Type{Module}, membuf::MemoryBuffer)\n\nParse bitcode from the given memory buffer into a module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Base.parse-Tuple{Type{LLVM.Module}, Vector}","page":"Modules","title":"Base.parse","text":"parse(::Type{Module}, data::Vector)\n\nParse bitcode from the given byte vector into a module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Base.convert-Tuple{Type{MemoryBuffer}, LLVM.Module}","page":"Modules","title":"Base.convert","text":"convert(::Type{MemoryBuffer}, mod::Module)\n\nConvert the given module to a memory buffer containing its bitcode.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Base.convert-Union{Tuple{T}, Tuple{Type{Vector{T}}, LLVM.Module}} where T<:Union{Int8, UInt8}","page":"Modules","title":"Base.convert","text":"convert(::Type{Vector}, mod::Module)\n\nConvert the given module to a byte vector containing its bitcode.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Base.write-Tuple{IO, LLVM.Module}","page":"Modules","title":"Base.write","text":"write(io::IO, mod::Module)\n\nWrite bitcode of the given module to the given IO stream.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Contents","page":"Modules","title":"Contents","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"globals\nprevglobal\nnextglobal\nfunctions(::LLVM.Module)\nprevfun\nnextfun\nflags(::LLVM.Module)","category":"page"},{"location":"lib/modules/#LLVM.globals","page":"Modules","title":"LLVM.globals","text":"globals(mod::LLVM.Module)\n\nGet an iterator over the global variables in the given module.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.prevglobal","page":"Modules","title":"LLVM.prevglobal","text":"prevglobal(gv::LLVM.GlobalVariable)\n\nGet the previous global variable in the module, or nothing if there is none.\n\nSee also: nextglobal.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.nextglobal","page":"Modules","title":"LLVM.nextglobal","text":"nextglobal(gv::LLVM.GlobalVariable)\n\nGet the next global variable in the module, or nothing if there is none.\n\nSee also: prevglobal.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.functions-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.functions","text":"functions(mod::LLVM.Module)\n\nGet an iterator over the functions in the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#LLVM.prevfun","page":"Modules","title":"LLVM.prevfun","text":"prevfun(fun::LLVM.Function)\n\nGet the previous function in the module, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.nextfun","page":"Modules","title":"LLVM.nextfun","text":"nextfun(fun::LLVM.Function)\n\nGet the next function in the module, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"lib/modules/#LLVM.flags-Tuple{LLVM.Module}","page":"Modules","title":"LLVM.flags","text":"flags(mod::LLVM.Module)\n\nGet a dictionary-like object representing the module flags of the given module.\n\nThis object can be used to get and set module flags, by calling getindex and setindex!.\n\n\n\n\n\n","category":"method"},{"location":"lib/modules/#Linking","page":"Modules","title":"Linking","text":"","category":"section"},{"location":"lib/modules/","page":"Modules","title":"Modules","text":"link!(::LLVM.Module, ::LLVM.Module)","category":"page"},{"location":"lib/modules/#LLVM.link!-Tuple{LLVM.Module, LLVM.Module}","page":"Modules","title":"LLVM.link!","text":"link!(dst::Module, src::Module)\n\nLink the source module src into the destination module dst. The source module is destroyed in the process.\n\n\n\n\n\n","category":"method"},{"location":"lib/hidden/#Hidden","page":"Hidden","title":"Hidden","text":"","category":"section"},{"location":"lib/hidden/","page":"Hidden","title":"Hidden","text":"Hidden docstrings that we don't want to show up, but we want to avoid failing checkdocs for:","category":"page"},{"location":"lib/hidden/","page":"Hidden","title":"Hidden","text":"LLVM.InitializeAArch64AsmParser\nLLVM.InitializeAArch64AsmPrinter\nLLVM.InitializeAArch64Disassembler\nLLVM.InitializeAArch64Target\nLLVM.InitializeAArch64TargetInfo\nLLVM.InitializeAArch64TargetMC\nLLVM.InitializeAMDGPUAsmParser\nLLVM.InitializeAMDGPUAsmPrinter\nLLVM.InitializeAMDGPUDisassembler\nLLVM.InitializeAMDGPUTarget\nLLVM.InitializeAMDGPUTargetInfo\nLLVM.InitializeAMDGPUTargetMC\nLLVM.InitializeARCAsmParser\nLLVM.InitializeARCAsmPrinter\nLLVM.InitializeARCDisassembler\nLLVM.InitializeARCTarget\nLLVM.InitializeARCTargetInfo\nLLVM.InitializeARCTargetMC\nLLVM.InitializeARMAsmParser\nLLVM.InitializeARMAsmPrinter\nLLVM.InitializeARMDisassembler\nLLVM.InitializeARMTarget\nLLVM.InitializeARMTargetInfo\nLLVM.InitializeARMTargetMC\nLLVM.InitializeAVRAsmParser\nLLVM.InitializeAVRAsmPrinter\nLLVM.InitializeAVRDisassembler\nLLVM.InitializeAVRTarget\nLLVM.InitializeAVRTargetInfo\nLLVM.InitializeAVRTargetMC\nLLVM.InitializeBPFAsmParser\nLLVM.InitializeBPFAsmPrinter\nLLVM.InitializeBPFDisassembler\nLLVM.InitializeBPFTarget\nLLVM.InitializeBPFTargetInfo\nLLVM.InitializeBPFTargetMC\nLLVM.InitializeColossusAsmParser\nLLVM.InitializeColossusAsmPrinter\nLLVM.InitializeColossusDisassembler\nLLVM.InitializeColossusTarget\nLLVM.InitializeColossusTargetInfo\nLLVM.InitializeColossusTargetMC\nLLVM.InitializeHexagonAsmParser\nLLVM.InitializeHexagonAsmPrinter\nLLVM.InitializeHexagonDisassembler\nLLVM.InitializeHexagonTarget\nLLVM.InitializeHexagonTargetInfo\nLLVM.InitializeHexagonTargetMC\nLLVM.InitializeLanaiAsmParser\nLLVM.InitializeLanaiAsmPrinter\nLLVM.InitializeLanaiDisassembler\nLLVM.InitializeLanaiTarget\nLLVM.InitializeLanaiTargetInfo\nLLVM.InitializeLanaiTargetMC\nLLVM.InitializeMipsAsmParser\nLLVM.InitializeMipsAsmPrinter\nLLVM.InitializeMipsDisassembler\nLLVM.InitializeMipsTarget\nLLVM.InitializeMipsTargetInfo\nLLVM.InitializeMipsTargetMC\nLLVM.InitializeMSP430AsmParser\nLLVM.InitializeMSP430AsmPrinter\nLLVM.InitializeMSP430Disassembler\nLLVM.InitializeMSP430Target\nLLVM.InitializeMSP430TargetInfo\nLLVM.InitializeMSP430TargetMC\nLLVM.InitializeNativeAsmParser\nLLVM.InitializeNativeAsmPrinter\nLLVM.InitializeNativeDisassembler\nLLVM.InitializeNativeTarget\nLLVM.InitializeNVPTXAsmParser\nLLVM.InitializeNVPTXAsmPrinter\nLLVM.InitializeNVPTXDisassembler\nLLVM.InitializeNVPTXTarget\nLLVM.InitializeNVPTXTargetInfo\nLLVM.InitializeNVPTXTargetMC\nLLVM.InitializePowerPCAsmParser\nLLVM.InitializePowerPCAsmPrinter\nLLVM.InitializePowerPCDisassembler\nLLVM.InitializePowerPCTarget\nLLVM.InitializePowerPCTargetInfo\nLLVM.InitializePowerPCTargetMC\nLLVM.InitializeRISCVAsmParser\nLLVM.InitializeRISCVAsmPrinter\nLLVM.InitializeRISCVDisassembler\nLLVM.InitializeRISCVTarget\nLLVM.InitializeRISCVTargetInfo\nLLVM.InitializeRISCVTargetMC\nLLVM.InitializeSparcAsmParser\nLLVM.InitializeSparcAsmPrinter\nLLVM.InitializeSparcDisassembler\nLLVM.InitializeSparcTarget\nLLVM.InitializeSparcTargetInfo\nLLVM.InitializeSparcTargetMC\nLLVM.InitializeSystemZAsmParser\nLLVM.InitializeSystemZAsmPrinter\nLLVM.InitializeSystemZDisassembler\nLLVM.InitializeSystemZTarget\nLLVM.InitializeSystemZTargetInfo\nLLVM.InitializeSystemZTargetMC\nLLVM.InitializeVEAsmParser\nLLVM.InitializeVEAsmPrinter\nLLVM.InitializeVEDisassembler\nLLVM.InitializeVETarget\nLLVM.InitializeVETargetInfo\nLLVM.InitializeVETargetMC\nLLVM.InitializeWebAssemblyAsmParser\nLLVM.InitializeWebAssemblyAsmPrinter\nLLVM.InitializeWebAssemblyDisassembler\nLLVM.InitializeWebAssemblyTarget\nLLVM.InitializeWebAssemblyTargetInfo\nLLVM.InitializeWebAssemblyTargetMC\nLLVM.InitializeX86AsmParser\nLLVM.InitializeX86AsmPrinter\nLLVM.InitializeX86Disassembler\nLLVM.InitializeX86Target\nLLVM.InitializeX86TargetInfo\nLLVM.InitializeX86TargetMC\nLLVM.InitializeXCoreAsmParser\nLLVM.InitializeXCoreAsmPrinter\nLLVM.InitializeXCoreDisassembler\nLLVM.InitializeXCoreTarget\nLLVM.InitializeXCoreTargetInfo\nLLVM.InitializeXCoreTargetMC","category":"page"},{"location":"lib/hidden/#LLVM.InitializeAArch64AsmParser","page":"Hidden","title":"LLVM.InitializeAArch64AsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAArch64AsmPrinter","page":"Hidden","title":"LLVM.InitializeAArch64AsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAArch64Disassembler","page":"Hidden","title":"LLVM.InitializeAArch64Disassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAArch64Target","page":"Hidden","title":"LLVM.InitializeAArch64Target","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAArch64TargetInfo","page":"Hidden","title":"LLVM.InitializeAArch64TargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAArch64TargetMC","page":"Hidden","title":"LLVM.InitializeAArch64TargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUAsmParser","page":"Hidden","title":"LLVM.InitializeAMDGPUAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUAsmPrinter","page":"Hidden","title":"LLVM.InitializeAMDGPUAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUDisassembler","page":"Hidden","title":"LLVM.InitializeAMDGPUDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUTarget","page":"Hidden","title":"LLVM.InitializeAMDGPUTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUTargetInfo","page":"Hidden","title":"LLVM.InitializeAMDGPUTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAMDGPUTargetMC","page":"Hidden","title":"LLVM.InitializeAMDGPUTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCAsmParser","page":"Hidden","title":"LLVM.InitializeARCAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCAsmPrinter","page":"Hidden","title":"LLVM.InitializeARCAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCDisassembler","page":"Hidden","title":"LLVM.InitializeARCDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCTarget","page":"Hidden","title":"LLVM.InitializeARCTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCTargetInfo","page":"Hidden","title":"LLVM.InitializeARCTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARCTargetMC","page":"Hidden","title":"LLVM.InitializeARCTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMAsmParser","page":"Hidden","title":"LLVM.InitializeARMAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMAsmPrinter","page":"Hidden","title":"LLVM.InitializeARMAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMDisassembler","page":"Hidden","title":"LLVM.InitializeARMDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMTarget","page":"Hidden","title":"LLVM.InitializeARMTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMTargetInfo","page":"Hidden","title":"LLVM.InitializeARMTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeARMTargetMC","page":"Hidden","title":"LLVM.InitializeARMTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRAsmParser","page":"Hidden","title":"LLVM.InitializeAVRAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRAsmPrinter","page":"Hidden","title":"LLVM.InitializeAVRAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRDisassembler","page":"Hidden","title":"LLVM.InitializeAVRDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRTarget","page":"Hidden","title":"LLVM.InitializeAVRTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRTargetInfo","page":"Hidden","title":"LLVM.InitializeAVRTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeAVRTargetMC","page":"Hidden","title":"LLVM.InitializeAVRTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFAsmParser","page":"Hidden","title":"LLVM.InitializeBPFAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFAsmPrinter","page":"Hidden","title":"LLVM.InitializeBPFAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFDisassembler","page":"Hidden","title":"LLVM.InitializeBPFDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFTarget","page":"Hidden","title":"LLVM.InitializeBPFTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFTargetInfo","page":"Hidden","title":"LLVM.InitializeBPFTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeBPFTargetMC","page":"Hidden","title":"LLVM.InitializeBPFTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusAsmParser","page":"Hidden","title":"LLVM.InitializeColossusAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusAsmPrinter","page":"Hidden","title":"LLVM.InitializeColossusAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusDisassembler","page":"Hidden","title":"LLVM.InitializeColossusDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusTarget","page":"Hidden","title":"LLVM.InitializeColossusTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusTargetInfo","page":"Hidden","title":"LLVM.InitializeColossusTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeColossusTargetMC","page":"Hidden","title":"LLVM.InitializeColossusTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonAsmParser","page":"Hidden","title":"LLVM.InitializeHexagonAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonAsmPrinter","page":"Hidden","title":"LLVM.InitializeHexagonAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonDisassembler","page":"Hidden","title":"LLVM.InitializeHexagonDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonTarget","page":"Hidden","title":"LLVM.InitializeHexagonTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonTargetInfo","page":"Hidden","title":"LLVM.InitializeHexagonTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeHexagonTargetMC","page":"Hidden","title":"LLVM.InitializeHexagonTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiAsmParser","page":"Hidden","title":"LLVM.InitializeLanaiAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiAsmPrinter","page":"Hidden","title":"LLVM.InitializeLanaiAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiDisassembler","page":"Hidden","title":"LLVM.InitializeLanaiDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiTarget","page":"Hidden","title":"LLVM.InitializeLanaiTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiTargetInfo","page":"Hidden","title":"LLVM.InitializeLanaiTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeLanaiTargetMC","page":"Hidden","title":"LLVM.InitializeLanaiTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsAsmParser","page":"Hidden","title":"LLVM.InitializeMipsAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsAsmPrinter","page":"Hidden","title":"LLVM.InitializeMipsAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsDisassembler","page":"Hidden","title":"LLVM.InitializeMipsDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsTarget","page":"Hidden","title":"LLVM.InitializeMipsTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsTargetInfo","page":"Hidden","title":"LLVM.InitializeMipsTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMipsTargetMC","page":"Hidden","title":"LLVM.InitializeMipsTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430AsmParser","page":"Hidden","title":"LLVM.InitializeMSP430AsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430AsmPrinter","page":"Hidden","title":"LLVM.InitializeMSP430AsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430Disassembler","page":"Hidden","title":"LLVM.InitializeMSP430Disassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430Target","page":"Hidden","title":"LLVM.InitializeMSP430Target","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430TargetInfo","page":"Hidden","title":"LLVM.InitializeMSP430TargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeMSP430TargetMC","page":"Hidden","title":"LLVM.InitializeMSP430TargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNativeAsmParser","page":"Hidden","title":"LLVM.InitializeNativeAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNativeAsmPrinter","page":"Hidden","title":"LLVM.InitializeNativeAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNativeDisassembler","page":"Hidden","title":"LLVM.InitializeNativeDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNativeTarget","page":"Hidden","title":"LLVM.InitializeNativeTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXAsmParser","page":"Hidden","title":"LLVM.InitializeNVPTXAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXAsmPrinter","page":"Hidden","title":"LLVM.InitializeNVPTXAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXDisassembler","page":"Hidden","title":"LLVM.InitializeNVPTXDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXTarget","page":"Hidden","title":"LLVM.InitializeNVPTXTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXTargetInfo","page":"Hidden","title":"LLVM.InitializeNVPTXTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeNVPTXTargetMC","page":"Hidden","title":"LLVM.InitializeNVPTXTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCAsmParser","page":"Hidden","title":"LLVM.InitializePowerPCAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCAsmPrinter","page":"Hidden","title":"LLVM.InitializePowerPCAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCDisassembler","page":"Hidden","title":"LLVM.InitializePowerPCDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCTarget","page":"Hidden","title":"LLVM.InitializePowerPCTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCTargetInfo","page":"Hidden","title":"LLVM.InitializePowerPCTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializePowerPCTargetMC","page":"Hidden","title":"LLVM.InitializePowerPCTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVAsmParser","page":"Hidden","title":"LLVM.InitializeRISCVAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVAsmPrinter","page":"Hidden","title":"LLVM.InitializeRISCVAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVDisassembler","page":"Hidden","title":"LLVM.InitializeRISCVDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVTarget","page":"Hidden","title":"LLVM.InitializeRISCVTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVTargetInfo","page":"Hidden","title":"LLVM.InitializeRISCVTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeRISCVTargetMC","page":"Hidden","title":"LLVM.InitializeRISCVTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcAsmParser","page":"Hidden","title":"LLVM.InitializeSparcAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcAsmPrinter","page":"Hidden","title":"LLVM.InitializeSparcAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcDisassembler","page":"Hidden","title":"LLVM.InitializeSparcDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcTarget","page":"Hidden","title":"LLVM.InitializeSparcTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcTargetInfo","page":"Hidden","title":"LLVM.InitializeSparcTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSparcTargetMC","page":"Hidden","title":"LLVM.InitializeSparcTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZAsmParser","page":"Hidden","title":"LLVM.InitializeSystemZAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZAsmPrinter","page":"Hidden","title":"LLVM.InitializeSystemZAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZDisassembler","page":"Hidden","title":"LLVM.InitializeSystemZDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZTarget","page":"Hidden","title":"LLVM.InitializeSystemZTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZTargetInfo","page":"Hidden","title":"LLVM.InitializeSystemZTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeSystemZTargetMC","page":"Hidden","title":"LLVM.InitializeSystemZTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVEAsmParser","page":"Hidden","title":"LLVM.InitializeVEAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVEAsmPrinter","page":"Hidden","title":"LLVM.InitializeVEAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVEDisassembler","page":"Hidden","title":"LLVM.InitializeVEDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVETarget","page":"Hidden","title":"LLVM.InitializeVETarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVETargetInfo","page":"Hidden","title":"LLVM.InitializeVETargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeVETargetMC","page":"Hidden","title":"LLVM.InitializeVETargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyAsmParser","page":"Hidden","title":"LLVM.InitializeWebAssemblyAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyAsmPrinter","page":"Hidden","title":"LLVM.InitializeWebAssemblyAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyDisassembler","page":"Hidden","title":"LLVM.InitializeWebAssemblyDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyTarget","page":"Hidden","title":"LLVM.InitializeWebAssemblyTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyTargetInfo","page":"Hidden","title":"LLVM.InitializeWebAssemblyTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeWebAssemblyTargetMC","page":"Hidden","title":"LLVM.InitializeWebAssemblyTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86AsmParser","page":"Hidden","title":"LLVM.InitializeX86AsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86AsmPrinter","page":"Hidden","title":"LLVM.InitializeX86AsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86Disassembler","page":"Hidden","title":"LLVM.InitializeX86Disassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86Target","page":"Hidden","title":"LLVM.InitializeX86Target","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86TargetInfo","page":"Hidden","title":"LLVM.InitializeX86TargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeX86TargetMC","page":"Hidden","title":"LLVM.InitializeX86TargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreAsmParser","page":"Hidden","title":"LLVM.InitializeXCoreAsmParser","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreAsmPrinter","page":"Hidden","title":"LLVM.InitializeXCoreAsmPrinter","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreDisassembler","page":"Hidden","title":"LLVM.InitializeXCoreDisassembler","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreTarget","page":"Hidden","title":"LLVM.InitializeXCoreTarget","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreTargetInfo","page":"Hidden","title":"LLVM.InitializeXCoreTargetInfo","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.InitializeXCoreTargetMC","page":"Hidden","title":"LLVM.InitializeXCoreTargetMC","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/","page":"Hidden","title":"Hidden","text":"LLVM.Int1Type\nLLVM.Int8Type\nLLVM.Int16Type\nLLVM.Int32Type\nLLVM.Int64Type\nLLVM.Int128Type","category":"page"},{"location":"lib/hidden/#LLVM.Int1Type","page":"Hidden","title":"LLVM.Int1Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.Int8Type","page":"Hidden","title":"LLVM.Int8Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.Int16Type","page":"Hidden","title":"LLVM.Int16Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.Int32Type","page":"Hidden","title":"LLVM.Int32Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.Int64Type","page":"Hidden","title":"LLVM.Int64Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.Int128Type","page":"Hidden","title":"LLVM.Int128Type","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/","page":"Hidden","title":"Hidden","text":"NewPMModulePassManager\nNewPMCGSCCPassManager\nNewPMFunctionPassManager\nNewPMLoopPassManager\nNewPMAAManager","category":"page"},{"location":"lib/hidden/#LLVM.NewPMModulePassManager","page":"Hidden","title":"LLVM.NewPMModulePassManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.NewPMCGSCCPassManager","page":"Hidden","title":"LLVM.NewPMCGSCCPassManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.NewPMFunctionPassManager","page":"Hidden","title":"LLVM.NewPMFunctionPassManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.NewPMLoopPassManager","page":"Hidden","title":"LLVM.NewPMLoopPassManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.NewPMAAManager","page":"Hidden","title":"LLVM.NewPMAAManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"type"},{"location":"lib/hidden/","page":"Hidden","title":"Hidden","text":"NewPMModulePass\nNewPMFunctionPass","category":"page"},{"location":"lib/hidden/#LLVM.NewPMModulePass","page":"Hidden","title":"LLVM.NewPMModulePass","text":"NewPMModulePass(name, callback)\nNewPMFunctionPass(name, callback)\n\nCreate a new custom pass. The name is a string that will be used to identify the pass in the pass manager. The callback is a function that will be called when the pass is run. The function should take a single argument, the module or function to be processed, and return a boolean indicating whether the pass made any changes.\n\nBefore using a custom pass, it must be registered with a pass builder using register!.\n\nSee also: register!\n\n\n\n\n\n","category":"function"},{"location":"lib/hidden/#LLVM.NewPMFunctionPass","page":"Hidden","title":"LLVM.NewPMFunctionPass","text":"NewPMModulePass(name, callback)\nNewPMFunctionPass(name, callback)\n\nCreate a new custom pass. The name is a string that will be used to identify the pass in the pass manager. The callback is a function that will be called when the pass is run. The function should take a single argument, the module or function to be processed, and return a boolean indicating whether the pass made any changes.\n\nBefore using a custom pass, it must be registered with a pass builder using register!.\n\nSee also: register!\n\n\n\n\n\n","category":"function"},{"location":"lib/transforms/#Transforms","page":"Transforms","title":"Transforms","text":"","category":"section"},{"location":"lib/transforms/#Pass-builders","page":"Transforms","title":"Pass builders","text":"","category":"section"},{"location":"lib/transforms/","page":"Transforms","title":"Transforms","text":"NewPMPassBuilder\nrun!","category":"page"},{"location":"lib/transforms/#LLVM.NewPMPassBuilder","page":"Transforms","title":"LLVM.NewPMPassBuilder","text":"NewPMPassBuilder(; verify_each=false, debug_logging=false, pipeline_tuning_kwargs...)\n\nCreate a new pass builder. The pass builder is the main object used to construct and run pass pipelines. The verify_each keyword argument enables module verification after each pass, while debug_logging can be used to enable more output. Pass builder objects needs to be disposed after use.\n\nSeveral other keyword arguments can be used to tune the pipeline. This only has an effect when using one of LLVM's default pipelines, like default<O3>:\n\nloop_interleaving::Bool=false: Enable loop interleaving.\nloop_vectorization::Bool=false: Enable loop vectorization.\nslp_vectorization::Bool=false: Enable SLP vectorization.\nloop_unrolling::Bool=false: Enable loop unrolling.\nforget_all_scev_in_loop_unroll::Bool=false: Forget all SCEV information in loop unrolling.\nlicm_mssa_opt_cap::Int=0: LICM MSSA optimization cap.\nlicm_mssa_no_acc_for_promotion_cap::Int=0: LICM MSSA no access for promotion cap.\ncall_graph_profile::Bool=false: Enable call graph profiling.\nmerge_functions::Bool=false: Enable function merging.\n\nAfter a pass builder is constructed, custom passes can be registered with register!, passes or nested pass managers can be added with add!, and finally the passes can be run with run!:\n\n@dispose pb = NewPMPassBuilder(verify_each=true) begin\n    register!(pb, SomeCustomPass())\n    add!(pb, SomeModulePass())\n    add!(pb, NewPMFunctionPassManager()) do fpm\n        add!(fpm, SomeFunctionPass())\n    end\n    run!(pb, mod, tm)\nend\n\nFor quickly running a simple pass or pipeline, a shorthand run! method is provided that obviates the construction of a NewPMPassBuilder:\n\nrun!(\"some-pass\", mod, tm; verify_each=true)\n\nSee also: register!, add!, run!\n\n\n\n\n\n","category":"type"},{"location":"lib/transforms/#LLVM.run!","page":"Transforms","title":"LLVM.run!","text":"run!(pb::NewPMPassBuilder, mod::Module, [tm::TargetMachine])\nrun!(pipeline::String, mod::Module, [tm::TargetMachine])\n\nRun passes on a module. The passes are specified by a pass builder or a string that represents a pass pipeline. The target machine is used to optimize the passes.\n\n\n\n\n\n","category":"function"},{"location":"lib/transforms/#Pass-managers","page":"Transforms","title":"Pass managers","text":"","category":"section"},{"location":"lib/transforms/","page":"Transforms","title":"Transforms","text":"LLVM.NewPMPassManager\nadd!","category":"page"},{"location":"lib/transforms/#LLVM.NewPMPassManager","page":"Transforms","title":"LLVM.NewPMPassManager","text":"NewPMModulePassManager()\nNewPMCGSCCPassManager()\nNewPMFunctionPassManager()\nNewPMLoopPassManager(; use_memory_ssa=false)\nNewPMAAManager()\n\nCreate a new pass manager of the specified type. These objects can be used to construct pass pipelines, by add!ing passes to them, and finally add!ing them to a parent pass manager or pass builder.\n\nCreating a pass manager and adding it to a parent manager or builder can be shortened using a single add!:\n\nadd!(parent, NewPMModulePassManager()) do mpm\n    add!(mpm, SomeModulePass())\nend\n\nSee also: add!, NewPMPassBuilder\n\n\n\n\n\n","category":"type"},{"location":"lib/transforms/#LLVM.add!","page":"Transforms","title":"LLVM.add!","text":"add!(pm::AbstractPassManager, pass)\n\nAdds a pass or pipeline to a pass builder or pass manager.\n\nThe pass or pipeline should be a string or string-convertible object known by LLVM. These can be constructed by using pass constructors, e.g., InternalizePass(), or by manually specifying names like default<O3>.\n\nWhen using custom passes, remember that they need to be registered with the pass builder before they can be used.\n\nSee also: register!\n\n\n\n\n\n","category":"function"},{"location":"lib/transforms/#Alias-analyses","page":"Transforms","title":"Alias analyses","text":"","category":"section"},{"location":"lib/transforms/","page":"Transforms","title":"Transforms","text":"","category":"page"},{"location":"lib/transforms/#Custom-passes","page":"Transforms","title":"Custom passes","text":"","category":"section"},{"location":"lib/transforms/","page":"Transforms","title":"Transforms","text":"LLVM.NewPMCustomPass\nregister!","category":"page"},{"location":"lib/transforms/#LLVM.NewPMCustomPass","page":"Transforms","title":"LLVM.NewPMCustomPass","text":"NewPMModulePass(name, callback)\nNewPMFunctionPass(name, callback)\n\nCreate a new custom pass. The name is a string that will be used to identify the pass in the pass manager. The callback is a function that will be called when the pass is run. The function should take a single argument, the module or function to be processed, and return a boolean indicating whether the pass made any changes.\n\nBefore using a custom pass, it must be registered with a pass builder using register!.\n\nSee also: register!\n\n\n\n\n\n","category":"type"},{"location":"lib/transforms/#LLVM.register!","page":"Transforms","title":"LLVM.register!","text":"register!(pb, custom_pass)\n\nRegister a custom pass with the pass builder. This is necessary before the pass can be used in a pass pipeline.\n\nSee also: NewPMModulePass, NewPMFunctionPass\n\n\n\n\n\n","category":"function"},{"location":"lib/transforms/#IR-cloning","page":"Transforms","title":"IR cloning","text":"","category":"section"},{"location":"lib/transforms/","page":"Transforms","title":"Transforms","text":"clone_into!\nclone","category":"page"},{"location":"lib/transforms/#LLVM.clone_into!","page":"Transforms","title":"LLVM.clone_into!","text":"clone_into!(new::LLVM.Function, old::LLVM.Function; [suffix::String],\n            [value_map::Dict{<:Value,<:Value}],\n            [changes::LLVM.LLVMCloneFunctionChangeType],\n            [type_mapper::Function],\n            [materializer::Function])\n\nClone the contents of a function old into a new function new. The value_map dictionary can be used to remap values from the old function to the new function, while suffix appends a suffix to all values cloned. The type_mapper and materializer functions can be used to respectively map types and materialize values on demand.\n\nThe changes argument determines how this function behaves; refer to the LLVM documentation of CloneFunctionInto for more details.\n\n\n\n\n\n","category":"function"},{"location":"lib/transforms/#LLVM.clone","page":"Transforms","title":"LLVM.clone","text":"clone(f::Function; [value_map::Dict{Value,Value}])\n\nSimpler version of clone_into! that clones a function f into a new function, optionally mapping values according to the value_map dictionary.\n\n\n\n\n\nclone(bb::BasicBlock]; dest=parent(bb), [suffix::String], [value_map::Dict{Value,Value}])\n\nClone a basic block bb by copying all instructions. The new block is inserted at the end of the parent function; this can be altered by setting dest to a different function, or to nothing to create a detached block. The suffix is appended to the name of the cloned basic block.\n\nwarn: Warn\nThis function only remaps values that are defined in the cloned basic block. Values defined outside the basic block (e.g. function arguments) are not remapped by default. This means that the cloned basic block can generally only be used within the same function that it was cloned from, unless you manually remap other values. This can be done passing a value_map dictionary.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVMType\nissized\ncontext(::LLVMType)\neltype(::LLVMType)","category":"page"},{"location":"lib/types/#LLVM.LLVMType","page":"Types","title":"LLVM.LLVMType","text":"LLVMType\n\nAbstract supertype for all LLVM types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.issized","page":"Types","title":"LLVM.issized","text":"issized(typ::LLVMType)\n\nReturn true if it makes sense to take the size of this type.\n\nNote that this does not mean that it's possible to call sizeof on this type, as LLVM types sizes can only queried given a target data layout.\n\nSee also: sizeof(::DataLayout, ::LLVMType).\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.context-Tuple{LLVMType}","page":"Types","title":"LLVM.context","text":"context(typ::LLVMType)\n\nReturns the context in which the given type was created.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Base.eltype-Tuple{LLVMType}","page":"Types","title":"Base.eltype","text":"eltype(typ::LLVMType)\n\nGet the element type of the given type, if supported.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Integer-types","page":"Types","title":"Integer types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.IntegerType\nLLVM.IntType\nwidth","category":"page"},{"location":"lib/types/#LLVM.IntegerType","page":"Types","title":"LLVM.IntegerType","text":"LLVM.IntegerType <: LLVMType\n\nType representing arbitrary bit width integers.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.IntType","page":"Types","title":"LLVM.IntType","text":"LLVM.IntType(bits::Integer)\n\nCreate an integer type with the given bits width.\n\nShort-hand constructors are available for common widths: LLVM.Int1Type, LLVM.Int8Type, LLVM.Int16Type, LLVM.Int32Type, LLVM.Int64Type, and LLVM.Int128Type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.width","page":"Types","title":"LLVM.width","text":"width(inttyp::LLVM.IntegerType)\n\nGet the bit width of the given integer type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Floating-point-types","page":"Types","title":"Floating-point types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.HalfType\nLLVM.BFloatType\nLLVM.FloatType\nLLVM.DoubleType\nLLVM.FP128Type\nLLVM.X86FP80Type\nLLVM.PPCFP128Type","category":"page"},{"location":"lib/types/#LLVM.HalfType","page":"Types","title":"LLVM.HalfType","text":"LLVM.HalfType()\n\nCreate a 16-bit floating-point type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.BFloatType","page":"Types","title":"LLVM.BFloatType","text":"LLVM.BFloatType()\n\nCreate a 16-bit “brain” floating-point type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.FloatType","page":"Types","title":"LLVM.FloatType","text":"LLVM.FloatType()\n\nCreate a 32-bit floating-point type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.DoubleType","page":"Types","title":"LLVM.DoubleType","text":"LLVM.DoubleType()\n\nCreate a 64-bit floating-point type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.FP128Type","page":"Types","title":"LLVM.FP128Type","text":"LLVM.FP128Type()\n\nCreate a 128-bit floating-point type, with a 113-bit significand.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.X86FP80Type","page":"Types","title":"LLVM.X86FP80Type","text":"LLVM.X86FP80Type()\n\nCreate a 80-bit, X87 floating-point type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.PPCFP128Type","page":"Types","title":"LLVM.PPCFP128Type","text":"LLVM.PPCFP128Type()\n\nCreate a 128-bit floating-point type, consisting of two 64-bits.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Function-types","page":"Types","title":"Function types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.FunctionType\nisvararg\nreturn_type\nparameters(::LLVM.FunctionType)","category":"page"},{"location":"lib/types/#LLVM.FunctionType","page":"Types","title":"LLVM.FunctionType","text":"LLVM.FunctionType <: LLVMType\n\nA function type, representing a function signature.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.isvararg","page":"Types","title":"LLVM.isvararg","text":"isvararg(ft::LLVM.FunctionType)\n\nCheck whether the given function type is variadic.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.return_type","page":"Types","title":"LLVM.return_type","text":"return_type(ft::LLVM.FunctionType)\n\nGet the return type of the given function type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.parameters-Tuple{LLVM.FunctionType}","page":"Types","title":"LLVM.parameters","text":"parameters(ft::LLVM.FunctionType)\n\nGet the parameter types of the given function type.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Pointer-types","page":"Types","title":"Pointer types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.PointerType\naddrspace\nis_opaque","category":"page"},{"location":"lib/types/#LLVM.PointerType","page":"Types","title":"LLVM.PointerType","text":"LLVM.PointerType <: LLVMType\n\nA pointer type.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.addrspace","page":"Types","title":"LLVM.addrspace","text":"addrspace(ptrtyp::LLVM.PointerType)\n\nGet the address space of the given pointer type.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.is_opaque","page":"Types","title":"LLVM.is_opaque","text":"is_opaque(ptrtyp::LLVM.PointerType)\n\nCheck whether the given pointer type is opaque.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Array-types","page":"Types","title":"Array types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.ArrayType\nlength(::LLVM.ArrayType)\nisempty(::LLVM.ArrayType)","category":"page"},{"location":"lib/types/#LLVM.ArrayType","page":"Types","title":"LLVM.ArrayType","text":"LLVM.ArrayType <: LLVMType\n\nAn array type, representing a fixed-size array of identically-typed elements.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Base.length-Tuple{LLVM.ArrayType}","page":"Types","title":"Base.length","text":"length(arrtyp::LLVM.ArrayType)\n\nGet the length of the given array type.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Base.isempty-Tuple{LLVM.ArrayType}","page":"Types","title":"Base.isempty","text":"isempty(arrtyp::LLVM.ArrayType)\n\nCheck whether the given array type is empty.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Vector-types","page":"Types","title":"Vector types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.VectorType\nlength(::LLVM.VectorType)","category":"page"},{"location":"lib/types/#LLVM.VectorType","page":"Types","title":"LLVM.VectorType","text":"LLVM.VectorType <: LLVMType\n\nA vector type, representing a fixed-size vector of identically-typed elements. Typically used for SIMD operations.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Base.length-Tuple{LLVM.VectorType}","page":"Types","title":"Base.length","text":"length(vectyp::LLVM.VectorType)\n\nGet the length of the given vector type.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#Structure-types","page":"Types","title":"Structure types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.StructType\nname(::LLVM.StructType)\nispacked\nisopaque\nelements!\nelements","category":"page"},{"location":"lib/types/#LLVM.StructType","page":"Types","title":"LLVM.StructType","text":"LLVM.StructType <: LLVMType\n\nA structure type, representing a collection of named fields of potentially different types.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.name-Tuple{LLVM.StructType}","page":"Types","title":"LLVM.name","text":"name(structtyp::StructType)\n\nGet the name of the given structure type.\n\n\n\n\n\n","category":"method"},{"location":"lib/types/#LLVM.ispacked","page":"Types","title":"LLVM.ispacked","text":"ispacked(structtyp::LLVM.StructType)\n\nCheck whether the given structure type is packed.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.isopaque","page":"Types","title":"LLVM.isopaque","text":"isopaque(structtyp::LLVM.StructType)\n\nCheck whether the given structure type is opaque.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.elements!","page":"Types","title":"LLVM.elements!","text":"elements!(structtyp::LLVM.StructType, elems::LLVMType[]; packed=false)\n\nSet the elements of the given structure type to elems. The packed argument indicates whether the structure should be packed, i.e., without padding between fields.\n\nSee also: elements.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#LLVM.elements","page":"Types","title":"LLVM.elements","text":"elements(structtyp::LLVM.StructType)\n\nGet the elements of the given structure type.\n\nSee also: elements!.\n\n\n\n\n\n","category":"function"},{"location":"lib/types/#Other-types","page":"Types","title":"Other types","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"LLVM.VoidType\nLLVM.LabelType\nLLVM.MetadataType\nLLVM.TokenType","category":"page"},{"location":"lib/types/#LLVM.VoidType","page":"Types","title":"LLVM.VoidType","text":"LLVM.VoidType <: LLVMType\n\nA void type, representing the absence of a value.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.LabelType","page":"Types","title":"LLVM.LabelType","text":"LLVM.LabelType <: LLVMType\n\nA label type, representing a code label.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.MetadataType","page":"Types","title":"LLVM.MetadataType","text":"LLVM.MetadataType <: LLVMType\n\nA metadata type, representing a metadata value.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#LLVM.TokenType","page":"Types","title":"LLVM.TokenType","text":"LLVM.TokenType <: LLVMType\n\nA token type, representing a token value.\n\n\n\n\n\n","category":"type"},{"location":"lib/types/#Type-iteration","page":"Types","title":"Type iteration","text":"","category":"section"},{"location":"lib/types/","page":"Types","title":"Types","text":"types","category":"page"},{"location":"lib/types/#LLVM.types","page":"Types","title":"LLVM.types","text":"types(ctx::LLVM.Context)\n\nGet a dictionary of all types in the given context.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Instructions","page":"Instructions","title":"Instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"Instruction\ncopy(::Instruction)\nremove!(::Instruction)\nerase!(::Instruction)\nLLVM.parent(::Instruction)","category":"page"},{"location":"lib/instructions/#LLVM.Instruction","page":"Instructions","title":"LLVM.Instruction","text":"Instruction\n\nAn instruction in the LLVM IR.\n\n\n\n\n\n","category":"type"},{"location":"lib/instructions/#Base.copy-Tuple{Instruction}","page":"Instructions","title":"Base.copy","text":"copy(inst::Instruction)\n\nCreate a copy of the given instruction.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.remove!-Tuple{Instruction}","page":"Instructions","title":"LLVM.remove!","text":"remove!(inst::Instruction)\n\nRemove the given instruction from the containing basic block, but do not delete the object.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.erase!-Tuple{Instruction}","page":"Instructions","title":"LLVM.erase!","text":"erase!(inst::Instruction)\n\nRemove the given instruction from the containing basic block and delete the object.\n\nwarning: Warning\nThis function is unsafe because it does not check if the instruction is used elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.parent-Tuple{Instruction}","page":"Instructions","title":"LLVM.parent","text":"parent(inst::Instruction)\n\nGet the basic block that contains the given instruction.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#Creating-instructions","page":"Instructions","title":"Creating instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"IRBuilder\nIRBuilder()\ndispose(::IRBuilder)\ncontext(::IRBuilder)\nposition\nposition!(::IRBuilder, ::Instruction)\nposition!(::IRBuilder, ::BasicBlock)\nposition!(::IRBuilder)\ninsert!(::IRBuilder, ::Instruction, ::String)\ndebuglocation\ndebuglocation!","category":"page"},{"location":"lib/instructions/#LLVM.IRBuilder","page":"Instructions","title":"LLVM.IRBuilder","text":"IRBuilder\n\nAn instruction builder, which is used to build instructions within a basic block.\n\n\n\n\n\n","category":"type"},{"location":"lib/instructions/#LLVM.IRBuilder-Tuple{}","page":"Instructions","title":"LLVM.IRBuilder","text":"IRBuilder()\n\nCreate a new, unpositioned instruction builder.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.dispose-Tuple{IRBuilder}","page":"Instructions","title":"LLVM.dispose","text":"dispose(builder::IRBuilder)\n\nDispose of an instruction builder.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.context-Tuple{IRBuilder}","page":"Instructions","title":"LLVM.context","text":"context(builder::IRBuilder)\n\nGet the context associated with an instruction builder.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#Base.position","page":"Instructions","title":"Base.position","text":"position(builder::IRBuilder)\n\nReturn the current position of the instruction builder.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.position!-Tuple{IRBuilder, Instruction}","page":"Instructions","title":"LLVM.position!","text":"position!(builder::IRBuilder, inst::Instruction)\n\nPosition the instruction builder before the given instruction.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.position!-Tuple{IRBuilder, BasicBlock}","page":"Instructions","title":"LLVM.position!","text":"position!(builder::IRBuilder, bb::BasicBlock)\n\nPosition the instruction builder at the end of the given basic block.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.position!-Tuple{IRBuilder}","page":"Instructions","title":"LLVM.position!","text":"position!(builder::IRBuilder)\n\nClear the current position of the instruction builder.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#Base.insert!-Tuple{IRBuilder, Instruction, String}","page":"Instructions","title":"Base.insert!","text":"insert!(builder::IRBuilder, inst::Instruction, [name::String])\n\nInsert an instruction into the current basic block at the current position, optionally giving it a name.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.debuglocation","page":"Instructions","title":"LLVM.debuglocation","text":"debuglocation(builder::IRBuilder)\n\nGet the current debug location of the instruction builder, or nothing if no location is set.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.debuglocation!","page":"Instructions","title":"LLVM.debuglocation!","text":"debuglocation!(builder::IRBuilder)\n\nClear the current debug location of the instruction builder.\n\n\n\n\n\ndebuglocation!(builder::IRBuilder, loc)\n\nSet the current debug location of the instruction builder to loc, which can be a Metadata or MetadataAsValue.\n\n\n\n\n\ndebuglocation!(builder::IRBuilder, inst::Instruction)\n\nSet the current debug location of the instruction builder to the location of the given instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Comparison-instructions","page":"Instructions","title":"Comparison instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"predicate","category":"page"},{"location":"lib/instructions/#LLVM.predicate","page":"Instructions","title":"LLVM.predicate","text":"predicate(inst::ICmpInst)\npredicate(inst::FCmpInst)\n\nGet the comparison predicate of the given integer or floating-point comparison instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Atomic-instructions","page":"Instructions","title":"Atomic instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"is_atomic\nordering\nordering!\nSyncScope\nsyncscope\nsyncscope!","category":"page"},{"location":"lib/instructions/#LLVM.is_atomic","page":"Instructions","title":"LLVM.is_atomic","text":"is_atomic(inst::Instruction)\n\nCheck if the given instruction is atomic. This includes atomic operations such as atomicrmw or fence, but also loads and stores that have been made atomic by setting an atomic ordering.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.ordering","page":"Instructions","title":"LLVM.ordering","text":"ordering(atomic_inst::Instruction)\n\nGet the atomic ordering of the given atomic instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.ordering!","page":"Instructions","title":"LLVM.ordering!","text":"ordering!(inst::Instruction, ordering::LLVM.AtomicOrdering)\n\nSet the atomic ordering of the given instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.SyncScope","page":"Instructions","title":"LLVM.SyncScope","text":"SyncScope\n\nA synchronization scope for atomic operations.\n\n\n\n\n\n","category":"type"},{"location":"lib/instructions/#LLVM.syncscope","page":"Instructions","title":"LLVM.syncscope","text":"syncscope(inst::AtomicInst)\n\nGet the synchronization scope of the given atomic instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.syncscope!","page":"Instructions","title":"LLVM.syncscope!","text":"syncscope!(inst::AtomicInst, scope::SyncScope)\n\nSet the synchronization scope of the given atomic instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Call-instructions","page":"Instructions","title":"Call instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"callconv(::LLVM.CallBase)\ncallconv!(::LLVM.CallBase, ::Any)\nistailcall\ntailcall!\ncalled_operand\narguments\ncalled_type","category":"page"},{"location":"lib/instructions/#LLVM.callconv-Tuple{Union{LLVM.CallBrInst, LLVM.CallInst, LLVM.InvokeInst}}","page":"Instructions","title":"LLVM.callconv","text":"callconv(call_inst::Instruction)\n\nGet the calling convention of the given callable instruction.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.callconv!-Tuple{Union{LLVM.CallBrInst, LLVM.CallInst, LLVM.InvokeInst}, Any}","page":"Instructions","title":"LLVM.callconv!","text":"callconv!(call_inst::Instruction, cc)\n\nSet the calling convention of the given callable instruction.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#LLVM.istailcall","page":"Instructions","title":"LLVM.istailcall","text":"istailcall(call_inst::Instruction)\n\nTests if this call site must be tail call optimized.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.tailcall!","page":"Instructions","title":"LLVM.tailcall!","text":"tailcall!(call_inst::Instruction, is_tail::Bool)\n\nSets whether this call site must be tail call optimized.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.called_operand","page":"Instructions","title":"LLVM.called_operand","text":"called_operand(call_inst::Instruction)\n\nGet the operand of a callable instruction that represents the called function.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.arguments","page":"Instructions","title":"LLVM.arguments","text":"arguments(call_inst::Instruction)\n\nGet the arguments of a callable instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.called_type","page":"Instructions","title":"LLVM.called_type","text":"called_type(call_inst::Instruction)\n\nGet the type of the function being called by the given callable instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Operand-Bundles","page":"Instructions","title":"Operand Bundles","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"OperandBundle\noperand_bundles\ntag\ninputs","category":"page"},{"location":"lib/instructions/#LLVM.OperandBundle","page":"Instructions","title":"LLVM.OperandBundle","text":"OperandBundle\n\nAn operand bundle attached to a call site.\n\n\n\n\n\n","category":"type"},{"location":"lib/instructions/#LLVM.operand_bundles","page":"Instructions","title":"LLVM.operand_bundles","text":"operand_bundles(call_inst::Instruction)\n\nGet the operand bundles attached to the given call instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.tag","page":"Instructions","title":"LLVM.tag","text":"tag(bundle::OperandBundle)\n\nGet the tag of the given operand bundle.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.inputs","page":"Instructions","title":"LLVM.inputs","text":"inputs(bundle::OperandBundle)\n\nGet an iterator over the inputs of the given operand bundle.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Terminator-instructions","page":"Instructions","title":"Terminator instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"isterminator\nisconditional\ncondition\ncondition!\ndefault_dest\nsuccessors(::Instruction)","category":"page"},{"location":"lib/instructions/#LLVM.isterminator","page":"Instructions","title":"LLVM.isterminator","text":"isterminator(inst::Instruction)\n\nCheck if the given instruction is a terminator instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.isconditional","page":"Instructions","title":"LLVM.isconditional","text":"isconditional(br::BrInst)\n\nCheck if the given branch instruction is conditional.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.condition","page":"Instructions","title":"LLVM.condition","text":"condition(br::BrInst)\n\nGet the condition of the given branch instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.condition!","page":"Instructions","title":"LLVM.condition!","text":"condition!(br::BrInst, cond::Value)\n\nSet the condition of the given branch instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.default_dest","page":"Instructions","title":"LLVM.default_dest","text":"default_dest(switch::SwitchInst)\n\nGet the default destination of the given switch instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.successors-Tuple{Instruction}","page":"Instructions","title":"LLVM.successors","text":"successors(term::Instruction)\n\nGet an iterator over the successors of the given terminator instruction.\n\nThis is a mutable iterator, so you can modify the successors of the terminator by calling setindex!.\n\n\n\n\n\n","category":"method"},{"location":"lib/instructions/#Phi-instructions","page":"Instructions","title":"Phi instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"incoming","category":"page"},{"location":"lib/instructions/#LLVM.incoming","page":"Instructions","title":"LLVM.incoming","text":"incoming(phi::PhiInst)\n\nGet an iterator over the incoming values of the given phi node.\n\nThis is a mutable iterator, so you can modify the incoming values of the phi node by calling push! or append!, passing a tuple of the incoming value and the originating basic block.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Floating-Point-instructions","page":"Instructions","title":"Floating Point instructions","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"fast_math\nfast_math!","category":"page"},{"location":"lib/instructions/#LLVM.fast_math","page":"Instructions","title":"LLVM.fast_math","text":"fast_math(inst::Instruction)\n\nGet the fast math flags on an instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.fast_math!","page":"Instructions","title":"LLVM.fast_math!","text":"fast_math!(inst::Instruction; [flag=...], [all=...])\n\nSet the fast math flags on an instruction. If all is true, then all flags are set.\n\nThe following flags are supported:\n\nnnan: assume arguments and results are not NaN\nninf: assume arguments and results are not Inf\nnsz: treat the sign of zero arguments and results as insignificant\narcp: allow use of reciprocal rather than perform division\ncontract: allow contraction of operations\nafn: allow substitution of approximate calculations for functions\nreassoc: allow reassociation of operations\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#Alignment","page":"Instructions","title":"Alignment","text":"","category":"section"},{"location":"lib/instructions/","page":"Instructions","title":"Instructions","text":"alignment\nalignment!","category":"page"},{"location":"lib/instructions/#LLVM.alignment","page":"Instructions","title":"LLVM.alignment","text":"alignment(val::LLVM.GlobalValue)\n\nGet the alignment of the global value.\n\n\n\n\n\nalignment(val::Instruction)\n\nGet the alignment of the instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/instructions/#LLVM.alignment!","page":"Instructions","title":"LLVM.alignment!","text":"alignment!(val::LLVM.GlobalValue, bytes::Integer)\n\nSet the alignment of the global value.\n\n\n\n\n\nalignment!(val::Instruction, bytes::Integer)\n\nSet the alignment of the instruction.\n\n\n\n\n\n","category":"function"},{"location":"man/instructions/#Instructions","page":"Instructions","title":"Instructions","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Instructions represent the operations that are executed by the program. They are grouped in basic blocks, and can be iterated using the instructions function. To create instructions, an instruction builder is used.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"The abstract LLVM.Instruction type supports a few additional APIs on top of the functionality from User and Value:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"parent: get the parent basic block of the instruction.\nopcode: get the opcode of the instruction.\nremove!/erase!: delete the instruction from its parent basic block, or additionally also delete the instruction itself.\nInstruction(::Instruction): clone an instruction","category":"page"},{"location":"man/instructions/#Creating-instructions","page":"Instructions","title":"Creating instructions","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    mod = LLVM.Module(\"SomeModule\")\n    fun = LLVM.Function(mod, \"SomeFunction\", LLVM.FunctionType(LLVM.VoidType()))\n    bb = BasicBlock(fun, \"entry\")\nend","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Instructions are created using an IRBuilder. This object is first positioned, and then used to create instructions by calling specific functions.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"To position an IRBuilder, several APIs are available:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"position: get the basic block where the builder is currently positioned.\nposition!(builder, ::Instruction): position the builder before an instruction.\nposition!(builder, ::BasicBlock): position the builder at the end of a basic block.\nposition!(builder): clear the position of the builder.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Given a pre-created Instruction, or more commonly an instruction that has been delete!d from a basic block, it is possible to insert it back into a different basic block by calling the insert! function.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"The essential functionality of the IRBuilder is the ability to create instructions. This is done by calling specific functions:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"julia> builder = IRBuilder();\n\njulia> position!(builder, bb)\n\njulia> ret!(builder);\n\njulia> bb\nentry:\n  ret void","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"For a full list of functions that can be used to create instructions, consult the API reference.","category":"page"},{"location":"man/instructions/#Debug-location","page":"Instructions","title":"Debug location","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"When creating instructions with an IRBuilder, it is possible to set a debug location for the instruction. This is done by calling the debuglocation! function on the builder:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"debuglocation!(builder): clear the debug location.\ndebuglocation!(builder, ::Metadata): set the debug location to a specific metadata.\ndebuglocation!(builder, ::Instruction): set the debug location to the same as another instruction.","category":"page"},{"location":"man/instructions/#Atomic-instructions","page":"Instructions","title":"Atomic instructions","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Atomic instructions support a few additional APIs:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"is_atomic: check if the instruction is atomic.\nordering/ordering!: get or set the ordering of the instruction.\nsyncscope/syncscope!: get or set the synchronization scope of the instruction to a specific SyncScope","category":"page"},{"location":"man/instructions/#Call-sites-instructions","page":"Instructions","title":"Call sites instructions","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Call site instructions include calls, invokes, and callbr instructions. These instruction types support a few additional APIs:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"callconv/callconv!: get or set the calling convention of the call site.\nistailcall/istailcall!: get or set whether the call site is a tail call.\ncalled_type: get the function type of the called value of the call site.\ncalled_operand: get the called value of the call site.\narguments: get the arguments of the call site.","category":"page"},{"location":"man/instructions/#Operand-bundles","page":"Instructions","title":"Operand bundles","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Calls can also be associated with operand bundles, which are tagged sets of SSA values that can be associated with certain LLVM instructions, but cannot be dropped like metadata can.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"To inspect the operand bundle of a call site, use the iterator returned by the operand_bundles function on a call site instruction. This iterator returns objects that support the following APIs:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"tag: get the tag of the operand bundle.\ninputs: get the inputs of the operand bundle, which itself is an iterator that can be indexed.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Operand bundles can also be created directly, using the OperandBundle constructor:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"julia> OperandBundle(\"deopt\")\n\"deopt\"()\n\njulia> OperandBundle(\"deopt\", [LLVM.ConstantInt(1)])\n\"deopt\"(i64 1)","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Whether constructed directly or looked up from a call site, operand bundles can be attached to a call site when calling the call! function on an IRBuilder.","category":"page"},{"location":"man/instructions/#Terminator-instructions","page":"Instructions","title":"Terminator instructions","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Terminator instructions are the last instructions in a basic block, and are used to control the flow of execution. They support a few additional APIs:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"isterminator: check if the instruction is a terminator.\nsuccessors: get the successors of the terminator.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"If the terminator is a branch, it's possible to check if the branch is conditional using the isconditional function, and get or set the condition using the condition and condition! functions.","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"If the terminator is a switch, it's possible to get the default destination using the default_dest function.","category":"page"},{"location":"man/instructions/#Phi-nodes","page":"Instructions","title":"Phi nodes","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Phi nodes are used to select a value based on the predecessor of a basic block. It's possible to inspect, and mutate, the incoming values using the iterator returned by the incoming function, which supports the following APIs:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"getindex: get the incoming value at a specific index.\npush!: add an incoming value (a value, block tuple) to the phi node.\nappend!: append multiple incoming values (an array of value, block tuples).","category":"page"},{"location":"man/instructions/#Fast-math-flags","page":"Instructions","title":"Fast math flags","text":"","category":"section"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    mod = LLVM.Module(\"SomeModule\")\n    fun = LLVM.Function(mod, \"SomeFunction\", LLVM.FunctionType(LLVM.VoidType(), [LLVM.FloatType()]))\n    bb = BasicBlock(fun, \"entry\")\n    builder = IRBuilder();\n    position!(builder, bb)\nend","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"Arithmetic instructions can be configured with different fast math flags, affecting optimizations that can be performed on the instruction. These flags can be queried and set using respectively the fast_math and fast_math! functions:","category":"page"},{"location":"man/instructions/","page":"Instructions","title":"Instructions","text":"julia> inst = fadd!(builder, parameters(fun)[1], ConstantFP(1f0))\n%1 = fadd float %0, 1.000000e+00\n\njulia> fast_math(inst)\n(nnan = false, ninf = false, nsz = false, arcp = false, contract = false, afn = false, reassoc = false)\n\njulia> fast_math!(inst; nnan=true)\n\njulia> inst\n%1 = fadd nnan float %0, 1.000000e+00","category":"page"},{"location":"lib/metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"LLVM.Metadata\nMDString\nMDString(::String)\nconvert(::Type{String}, ::MDString)\nMDNode\noperands(::MDNode)\nMDTuple\nMDNode(::Vector)","category":"page"},{"location":"lib/metadata/#LLVM.Metadata","page":"Metadata","title":"LLVM.Metadata","text":"Metadata\n\nAbstract supertype for all metadata types.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.MDString","page":"Metadata","title":"LLVM.MDString","text":"MDString\n\nA string metadata node.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.MDString-Tuple{String}","page":"Metadata","title":"LLVM.MDString","text":"MDString(val::String)\n\nCreate a new string metadata node from the given Julia string.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Base.convert-Tuple{Type{String}, MDString}","page":"Metadata","title":"Base.convert","text":"convert(String, md::MDString)\n\nGet the string value of the given string metadata node.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.MDNode","page":"Metadata","title":"LLVM.MDNode","text":"MDNode\n\nAbstract supertype for metadata nodes that can have operands.\n\nSee also: MDTuple for a concrete subtype.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.operands-Tuple{MDNode}","page":"Metadata","title":"LLVM.operands","text":"operands(md::MDNode)\n\nGet the operands of the given metadata node.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.MDTuple","page":"Metadata","title":"LLVM.MDTuple","text":"MDTuple\n\nA tuple metadata node.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.MDNode-Tuple{Vector}","page":"Metadata","title":"LLVM.MDNode","text":"MDNode(vals::Vector) -> MDTuple\n\nCreate a new tuple metadata node from the given operands.\n\nPassing nothing as a value will result in a null operand.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Metadata-Value","page":"Metadata","title":"Metadata <-> Value","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"LLVM.ValueAsMetadata\nMetadata(::Value)\nLLVM.MetadataAsValue\nValue(::Metadata)","category":"page"},{"location":"lib/metadata/#LLVM.ValueAsMetadata","page":"Metadata","title":"LLVM.ValueAsMetadata","text":"LLVM.ValueAsMetadata\n\nAbstract type for values wrapped as metadata, for use in APIs that expect a LLVM.Metadata.\n\nSee also: Metadata(::Value) to convert back to a metadata.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.Metadata-Tuple{Value}","page":"Metadata","title":"LLVM.Metadata","text":"Metadata(val::Value)\n\nWrap the given value as metadata, for use in APIs that expect a LLVM.Metadata.\n\nWhen the value is already metadata wrapped as a value, this will simply return the original metadata.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.MetadataAsValue","page":"Metadata","title":"LLVM.MetadataAsValue","text":"LLVM.MetadataAsValue\n\nMetadata wrapped as a regular value, for use in APIs that expect a LLVM.Value.\n\nSee also: Value(::Metadata) to convert back to a value.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.Value-Tuple{Metadata}","page":"Metadata","title":"LLVM.Value","text":"Value(md::Metadata)\n\nWrap the given metadata as a value, for use in APIs that expect a LLVM.Value.\n\nWhen the metadata is already a value wrapped as metadata, this will simply return the original value.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Inspecting-and-attaching","page":"Metadata","title":"Inspecting and attaching","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"metadata(::Union{Instruction, LLVM.GlobalObject})\nNamedMDNode\nmetadata(::LLVM.Module)\nname(::NamedMDNode)\noperands(::NamedMDNode)\npush!(::NamedMDNode, ::MDNode)","category":"page"},{"location":"lib/metadata/#LLVM.metadata-Tuple{Union{LLVM.GlobalObject, Instruction}}","page":"Metadata","title":"LLVM.metadata","text":"metadata(inst::Instruction)\nmetadata(inst::GlobalObject)\n\nIterate over the metadata of the given instruction or global object.\n\nThese iterators are mutable, and implement setindex! and delete! to modify the metadata.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.NamedMDNode","page":"Metadata","title":"LLVM.NamedMDNode","text":"NamedMDNode\n\nA named metadata node, which is a collection of metadata nodes with a name.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.metadata-Tuple{LLVM.Module}","page":"Metadata","title":"LLVM.metadata","text":"metadata(mod)\n\nFetch the module-level named metadata. This can be inspected using a Dict-like interface. Mutation is different: There is no setindex! method, as named metadata is append-only. Instead, fetch the named metadata node using getindex, and push! to it.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.name-Tuple{NamedMDNode}","page":"Metadata","title":"LLVM.name","text":"name(node::NamedMDNode)\n\nGet the name of the given named metadata node.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.operands-Tuple{NamedMDNode}","page":"Metadata","title":"LLVM.operands","text":"operands(node::NamedMDNode)\n\nGet the operands of the given named metadata node.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Base.push!-Tuple{NamedMDNode, MDNode}","page":"Metadata","title":"Base.push!","text":"push!(node::NamedMDNode, val::MDNode)\n\nAdd a metadata node to the given named metadata node.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Debug-information","page":"Metadata","title":"Debug information","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DINode","category":"page"},{"location":"lib/metadata/#LLVM.DINode","page":"Metadata","title":"LLVM.DINode","text":"DINode\n\na tagged DWARF-like metadata node.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#Location-information","page":"Metadata","title":"Location information","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DILocation\nline(::DILocation)\ncolumn\nscope(::DILocation)\ninlined_at","category":"page"},{"location":"lib/metadata/#LLVM.DILocation","page":"Metadata","title":"LLVM.DILocation","text":"DILocation\n\nA location in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.line-Tuple{DILocation}","page":"Metadata","title":"LLVM.line","text":"line(location::DILocation)\n\nGet the line number of this debug location.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.column","page":"Metadata","title":"LLVM.column","text":"column(location::DILocation)\n\nGet the column number of this debug location.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#LLVM.scope-Tuple{DILocation}","page":"Metadata","title":"LLVM.scope","text":"scope(location::DILocation)\n\nGet the local scope associated with this debug location.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.inlined_at","page":"Metadata","title":"LLVM.inlined_at","text":"inlined_at(location::DILocation)\n\nGet the \"inline at\" location associated with this debug location.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#Variables","page":"Metadata","title":"Variables","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DIVariable\nLLVM.DILocalVariable\nLLVM.DIGlobalVariable\nfile(::DIVariable)\nscope(::DIVariable)\nline(::DIVariable)","category":"page"},{"location":"lib/metadata/#LLVM.DIVariable","page":"Metadata","title":"LLVM.DIVariable","text":"DIVariable\n\nAbstract supertype for all variable-like metadata nodes.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.DILocalVariable","page":"Metadata","title":"LLVM.DILocalVariable","text":"DILocalVariable <: DIVariable\n\nA local variable in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.DIGlobalVariable","page":"Metadata","title":"LLVM.DIGlobalVariable","text":"DIGlobalVariable <: DIVariable\n\nA global variable in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.file-Tuple{DIVariable}","page":"Metadata","title":"LLVM.file","text":"file(var::DIVariable)\n\nGet the file of the given variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.scope-Tuple{DIVariable}","page":"Metadata","title":"LLVM.scope","text":"name(var::DIVariable)\n\nGet the name of the given variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.line-Tuple{DIVariable}","page":"Metadata","title":"LLVM.line","text":"line(var::DIVariable)\n\nGet the line number of the given variable.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Scopes","page":"Metadata","title":"Scopes","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DIScope\nfile(::DIScope)\nname(::DIScope)","category":"page"},{"location":"lib/metadata/#LLVM.DIScope","page":"Metadata","title":"LLVM.DIScope","text":"DIScope\n\nAbstract supertype for lexical scopes and types (which are also declaration contexts).\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.file-Tuple{DIScope}","page":"Metadata","title":"LLVM.file","text":"file(scope::DIScope)\n\nGet the metadata of the file associated with a given scope.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.name-Tuple{DIScope}","page":"Metadata","title":"LLVM.name","text":"name(scope::DIScope)\n\nGet the name of the given scope.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#File","page":"Metadata","title":"File","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DIFile\ndirectory\nfilename\nsource","category":"page"},{"location":"lib/metadata/#LLVM.DIFile","page":"Metadata","title":"LLVM.DIFile","text":"DIFile\n\nA file in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.directory","page":"Metadata","title":"LLVM.directory","text":"directory(file::DIFile)\n\nGet the directory of a given file.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#LLVM.filename","page":"Metadata","title":"LLVM.filename","text":"filename(file::DIFile)\n\nGet the filename of the given file.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#LLVM.source","page":"Metadata","title":"LLVM.source","text":"source(file::DIFile)\n\nGet the source of the given file, or nothing if the source is not available.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#Type","page":"Metadata","title":"Type","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DIType\nname(::DIType)\nBase.sizeof(::DIType)\noffset(::DIType)\nline(::DIType)\nflags(::DIType)","category":"page"},{"location":"lib/metadata/#LLVM.DIType","page":"Metadata","title":"LLVM.DIType","text":"DIType\n\nAbstract supertype for all type-like metadata nodes.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.name-Tuple{DIType}","page":"Metadata","title":"LLVM.name","text":"name(typ::DIType)\n\nGet the name of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Base.sizeof-Tuple{DIType}","page":"Metadata","title":"Base.sizeof","text":"sizeof(typ::DIType)\n\nGet the size in bits of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.offset-Tuple{DIType}","page":"Metadata","title":"LLVM.offset","text":"offset(typ::DIType)\n\nGet the offset in bits of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.line-Tuple{DIType}","page":"Metadata","title":"LLVM.line","text":"line(typ::DIType)\n\nGet the line number of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.flags-Tuple{DIType}","page":"Metadata","title":"LLVM.flags","text":"flags(typ::DIType)\n\nGet the flags of the given type.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Subprogram","page":"Metadata","title":"Subprogram","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DISubProgram\nline(::DISubProgram)","category":"page"},{"location":"lib/metadata/#LLVM.DISubProgram","page":"Metadata","title":"LLVM.DISubProgram","text":"DISubProgram\n\nA subprogram in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#LLVM.line-Tuple{DISubProgram}","page":"Metadata","title":"LLVM.line","text":"line(subprogram::DISubProgram)\n\nGet the line number of the given subprogram.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#Compile-Unit","page":"Metadata","title":"Compile Unit","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DICompileUnit","category":"page"},{"location":"lib/metadata/#LLVM.DICompileUnit","page":"Metadata","title":"LLVM.DICompileUnit","text":"DICompileUnit\n\nA compilation unit in the source code.\n\n\n\n\n\n","category":"type"},{"location":"lib/metadata/#Other","page":"Metadata","title":"Other","text":"","category":"section"},{"location":"lib/metadata/","page":"Metadata","title":"Metadata","text":"DEBUG_METADATA_VERSION\nstrip_debuginfo!\nsubprogram(::LLVM.Function)\nsubprogram!","category":"page"},{"location":"lib/metadata/#LLVM.DEBUG_METADATA_VERSION","page":"Metadata","title":"LLVM.DEBUG_METADATA_VERSION","text":"DEBUG_METADATA_VERSION()\n\nThe current debug info version number, as supported by LLVM.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#LLVM.strip_debuginfo!","page":"Metadata","title":"LLVM.strip_debuginfo!","text":"strip_debuginfo!(mod::Module)\n\nStrip the debug information from the given module.\n\n\n\n\n\n","category":"function"},{"location":"lib/metadata/#LLVM.subprogram-Tuple{LLVM.Function}","page":"Metadata","title":"LLVM.subprogram","text":"subprogram(func::Function) -> DISubProgram\n\nGet the subprogram of the given function, or nothing if the function has no subprogram.\n\n\n\n\n\n","category":"method"},{"location":"lib/metadata/#LLVM.subprogram!","page":"Metadata","title":"LLVM.subprogram!","text":"subprogram!(func::Function, sp::DISubProgram)\n\nSet the subprogram of the given function.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"LLVM.Function\nLLVM.Function(::LLVM.Module, ::String, ::LLVM.FunctionType)","category":"page"},{"location":"lib/functions/#LLVM.Function","page":"Functions","title":"LLVM.Function","text":"LLVM.Function\n\nA function in the IR.\n\n\n\n\n\n","category":"type"},{"location":"lib/functions/#LLVM.Function-Tuple{LLVM.Module, String, LLVM.FunctionType}","page":"Functions","title":"LLVM.Function","text":"LLVM.Function(mod::Module, name::String, ft::FunctionType)\n\nCreate a new function in the given module with the given name and function type.\n\n\n\n\n\n","category":"method"},{"location":"lib/functions/#Properties-and-operations","page":"Functions","title":"Properties and operations","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"function_type\nempty!\nerase!(::LLVM.Function)\npersonality\npersonality!\ncallconv\ncallconv!\ngc\ngc!\nentry","category":"page"},{"location":"lib/functions/#LLVM.function_type","page":"Functions","title":"LLVM.function_type","text":"function_type(f::Function) -> LLVM.FunctionType\n\nGet the function type of the given function. This returns a function type, as opposed to value_type which returns the pointer type of the function constant.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Base.empty!","page":"Functions","title":"Base.empty!","text":"empty!(f::Function)\n\nDelete the body of the given function, and convert the linkage to external.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.erase!-Tuple{LLVM.Function}","page":"Functions","title":"LLVM.erase!","text":"erase!(f::Function)\n\nRemove the given function from its parent module and free the object.\n\nwarning: Warning\nThis function is unsafe because it does not check if the function is used elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"lib/functions/#LLVM.personality","page":"Functions","title":"LLVM.personality","text":"personality(f::Function)\n\nGet the personality function of the given function, or nothing if it has none.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.personality!","page":"Functions","title":"LLVM.personality!","text":"personality!(f::Function, persfn::Function)\n\nSet the personality function of the given function. Pass nothing to remove the personality function.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.callconv","page":"Functions","title":"LLVM.callconv","text":"callconv(f::Function)\n\nGet the calling convention of the given function.\n\n\n\n\n\ncallconv(call_inst::Instruction)\n\nGet the calling convention of the given callable instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.callconv!","page":"Functions","title":"LLVM.callconv!","text":"callconv!(f::Function, cc)\n\nSet the calling convention of the given function.\n\n\n\n\n\ncallconv!(call_inst::Instruction, cc)\n\nSet the calling convention of the given callable instruction.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.gc","page":"Functions","title":"LLVM.gc","text":"gc(f::Function)\n\nGet the garbage collector name of the given function, or an empty string if it has none.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.gc!","page":"Functions","title":"LLVM.gc!","text":"gc!(f::Function, name::String)\n\nSet the garbage collector name of the given function.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.entry","page":"Functions","title":"LLVM.entry","text":"entry(f::Function) -> BasicBlock\n\nGet the entry basic block of the given function.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Attributes","page":"Functions","title":"Attributes","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"function_attributes\nparameter_attributes\nreturn_attributes","category":"page"},{"location":"lib/functions/#LLVM.function_attributes","page":"Functions","title":"LLVM.function_attributes","text":"function_attributes(f::Function)\n\nGet the attributes of the given function.\n\nThis is a mutable iterator, supporting push!, append! and delete!.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.parameter_attributes","page":"Functions","title":"LLVM.parameter_attributes","text":"parameter_attributes(f::Function, idx::Integer)\n\nGet the attributes of the given parameter of the given function.\n\nThis is a mutable iterator, supporting push!, append! and delete!.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.return_attributes","page":"Functions","title":"LLVM.return_attributes","text":"return_attributes(f::Function)\n\nGet the attributes of the return value of the given function.\n\nThis is a mutable iterator, supporting push!, append! and delete!.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Parameters","page":"Functions","title":"Parameters","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"parameters","category":"page"},{"location":"lib/functions/#LLVM.parameters","page":"Functions","title":"LLVM.parameters","text":"parameters(ft::LLVM.FunctionType)\n\nGet the parameter types of the given function type.\n\n\n\n\n\nparameters(f::Function)\n\nGet an iterator over the parameters of the given function. These are values that can be used as inputs to other instructions.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Basic-Blocks","page":"Functions","title":"Basic Blocks","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"blocks\nprevblock\nnextblock","category":"page"},{"location":"lib/functions/#LLVM.blocks","page":"Functions","title":"LLVM.blocks","text":"blocks(f::Function)\n\nGet an iterator over the basic blocks of the given function.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.prevblock","page":"Functions","title":"LLVM.prevblock","text":"prevblock(bb::BasicBlock)\n\nGet the previous basic block of the given basic block, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.nextblock","page":"Functions","title":"LLVM.nextblock","text":"nextblock(bb::BasicBlock)\n\nGet the next basic block of the given basic block, or nothing if there is none.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#Intrinsics","page":"Functions","title":"Intrinsics","text":"","category":"section"},{"location":"lib/functions/","page":"Functions","title":"Functions","text":"isintrinsic\nisoverloaded\nname(::Intrinsic)\nname(::Intrinsic, ::Vector{<:LLVMType})\nLLVM.Function(::LLVM.Module, ::Intrinsic, ::Vector{<:LLVMType})\nLLVM.FunctionType(::Intrinsic, ::Vector{<:LLVMType})","category":"page"},{"location":"lib/functions/#LLVM.isintrinsic","page":"Functions","title":"LLVM.isintrinsic","text":"isintrinsic(f::Function)\n\nCheck if the given function is an intrinsic.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.isoverloaded","page":"Functions","title":"LLVM.isoverloaded","text":"isoverloaded(intr::Intrinsic)\n\nCheck if the given intrinsic is overloaded.\n\n\n\n\n\n","category":"function"},{"location":"lib/functions/#LLVM.name-Tuple{Intrinsic}","page":"Functions","title":"LLVM.name","text":"name(intr::LLVM.Intrinsic)\n\nGet the name of the given intrinsic.\n\n\n\n\n\n","category":"method"},{"location":"lib/functions/#LLVM.name-Tuple{Intrinsic, Vector{<:LLVMType}}","page":"Functions","title":"LLVM.name","text":"name(intr::LLVM.Intrinsic, params::Vector{<:LLVMType})\n\nGet the name of the given overloaded intrinsic with the given parameter types.\n\n\n\n\n\n","category":"method"},{"location":"lib/functions/#LLVM.Function-Tuple{LLVM.Module, Intrinsic, Vector{<:LLVMType}}","page":"Functions","title":"LLVM.Function","text":"Function(mod::Module, intr::Intrinsic, params::Vector{<:LLVMType}=LLVMType[])\n\nGet the declaration of the given intrinsic in the given module.\n\n\n\n\n\n","category":"method"},{"location":"lib/functions/#LLVM.FunctionType-Tuple{Intrinsic, Vector{<:LLVMType}}","page":"Functions","title":"LLVM.FunctionType","text":"FunctionType(intr::Intrinsic, params::Vector{<:LLVMType}=LLVMType[])\n\nGet the function type of the given intrinsic with the given parameter types.\n\n\n\n\n\n","category":"method"},{"location":"man/values/#Values","page":"Values","title":"Values","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Values are the basic building blocks of a program. They are the simplest form of data that can be manipulated by a program. Many things in LLVM are considered a value: not only constants, but also instructions, functions, etc.","category":"page"},{"location":"man/values/#General-APIs","page":"Values","title":"General APIs","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"The Value type is the abstract type that represents all values in LLVM. It supports a range of general APIs that are common to all values:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"value_type: get the type of the value.\ncontext: get the context in which the value was created.\nname!/name: get or set the name of the value.","category":"page"},{"location":"man/values/#User-values","page":"Values","title":"User values","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"A User is a value that can have other values as operands. It is the base type for instructions, functions, and other values that are composed of other values. It supports a few additional APIs:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"operands: get the operands of the user.","category":"page"},{"location":"man/values/#Constant-values","page":"Values","title":"Constant values","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"Many values are actually constant, i.e., they are known to be immutable at run time. Constant numbers are examples of constants, but also functions and global variables, because their address is immutable.","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"It is possible to quickly create all-zeros and all-ones constants using the null and all_ones functions:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> null(LLVM.Int1Type())\ni1 false\n\njulia> all_ones(LLVM.FloatType())\nfloat 0xFFFFFFFFE0000000","category":"page"},{"location":"man/values/#Constant-data","page":"Values","title":"Constant data","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"There are several kinds of constant data that can be represented in LLVM. Singleton constants, which include null, undef, and poison values, can be created using constructors that take a single type as argument:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> PointerNull(LLVM.PointerType(LLVM.Int1Type()))\ni1* null\n\njulia> UndefValue(LLVM.Int1Type())\ni1 undef\n\njulia> PoisonValue(LLVM.Int1Type())\ni1 poison","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Constant numbers can be created by passing a type and a value, or simply a value in which case the Julia type will be mapped to the corresponding LLVM type:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> ConstantInt(LLVM.Int1Type(), 1)\ni1 true\n\njulia> ConstantInt(true)\ni1 true\n\njulia> ConstantFP(LLVM.FloatType(), 1.0)\nfloat 1.000000e+00\n\njulia> ConstantFP(1.0f0)\nfloat 1.000000e+00","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"It is possible to extract the value of a constant using the convert function:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> c = ConstantFP(Float16(1))\nhalf 0xH3C00\n\njulia> convert(Float16, c)\nFloat16(1.0)","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Constant structures can be created using the ConstantStruct constructor:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> ty = LLVM.StructType([LLVM.Int32Type()])\n{ i32 }\n\njulia> ConstantStruct(ty, [LLVM.ConstantInt(Int32(42))])\n{ i32 } { i32 42 }\n\njulia> # short-hand where the LLVM type is inferred\n       ConstantStruct([LLVM.ConstantInt(Int32(42))])\n{ i32 } { i32 42 }","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Sequential constants, i.e., arrays and vectors, can be created using the ConstantDataArray and ConstantDataVector constructors, which again supports the shorthand of only passing Julia values:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> ConstantDataArray(LLVM.Int32Type(), Int32[1, 2])\n[2 x i32] [i32 1, i32 2]\n\njulia> # short-hand where the LLVM type is inferred\n       ConstantDataArray(Int32[1, 2])\n[2 x i32] [i32 1, i32 2]","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"note: Note\nConstantDataVector is currently not implemented.","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"While ConstantDataArray only supports simple element types, ConstantArray supports arbitrary aggregates as elements:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> val = ConstantStruct([LLVM.ConstantInt(Int32(42))])\n{ i32 } { i32 42 }\n\njulia> ty = value_type(val)\n{ i32 }\n\njulia> ConstantArray(ty, [val])\n[1 x { i32 }] [{ i32 } { i32 42 }]","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Both ConstantDataArray and ConstantArray can, to some extent, be manipulated with plain Julia array operations:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> arr = ConstantArray([1, 2])\n[2 x i64] [i64 1, i64 2]\n\njulia> length(arr)\n2\n\njulia> arr[1]\ni64 1","category":"page"},{"location":"man/values/#Constant-expressions","page":"Values","title":"Constant expressions","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"Constant expressions are a way to represent computations that are known at compile time. Their support in LLVM is diminishing, and their results are often constant-folded to other constants, but the ones that remain can be constructed with const_-prefixed functions in LLVM.jl:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> const_neg(ConstantInt(1))\ni64 -1\n\njulia> const_inttoptr(ConstantInt(42), LLVM.PointerType(LLVM.Int1Type()))\ni1* inttoptr (i64 42 to i1*)","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"For the exact list of supported constant expressions, refer to the LLVM documentation.","category":"page"},{"location":"man/values/#Inline-assembly","page":"Values","title":"Inline assembly","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"Inline assembly is a way to include raw assembly code in a program. It is often used to access features that are not directly supported by LLVM, or to optimize specific parts of a program.","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"The InlineAsm constructor takes a function type, assembly string, constraints string, and a boolean indicating whether the assembly has side effects:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> InlineAsm(LLVM.FunctionType(LLVM.VoidType()), \"nop\", \"\", false)\nvoid ()* asm \"nop\", \"\"","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"For more details on inline assembly, particularly the format of the constraints string, refer to the LLVM documentation.","category":"page"},{"location":"man/values/#Global-values","page":"Values","title":"Global values","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"Global values are values that are encoded at the top level of a module. They support a couple of additional APIs:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"global_value_type: get the type of the global value.\nisdeclaration: whether the global value is a declaration, i.e., it does not have a body.\nlinkage/linkage!: get or set the linkage of the global value.\nvisibility/visibility!: get or set the visibility of the global value.\nsection/section!: get or set the section of the global value.\nalignment/alignment!: get or set the alignment of the global value.\ndllstorage/dllstorage!: get or set the DLL storage class of the global value.\nunnamed_addr/unnamed_addr!: get or set whether the global value has an unnamed address.","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"The most common type of global value is the global variable, which can be created using the GlobalVariable constructor:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> mod = LLVM.Module(\"SomeModule\");\n\njulia> ty = LLVM.Int32Type();\n\njulia> gv = GlobalVariable(mod, ty, \"SomeGV\")\n@SomeGV = external global i32","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"Global variables support additional APIs:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"initializer/initializer!: get or set the initializer of the global variable to a constant value (pass nothing to remove the initializer).\nisthreadlocal/isthreadlocal!: get or set whether the global variable is thread-local.\nisconstant/isconstant!: get or set whether the global variable is constant.\nisextinit/isextinit!: get or set whether the global variable is externally initialized.\nerase!: delete the global variable from its parent module, and delete the object.","category":"page"},{"location":"man/values/#Uses","page":"Values","title":"Uses","text":"","category":"section"},{"location":"man/values/","page":"Values","title":"Values","text":"It is possible to inspect the uses of a value using the iterator returned by the uses function. This iterator returns Use objects which contain both the user and the original value:","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> c1 = ConstantInt(42);\n\njulia> c2 = const_inttoptr(c1, LLVM.PointerType(LLVM.Int1Type()));\n\njulia> use = only(uses(c1));\n\njulia> user(use)\ni1* inttoptr (i64 42 to i1*)\n\njulia> value(use)\ni64 42","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"It is also possible to replace uses of a value using the replace_uses! function (commonly referred to as \"RAUW\" in LLVM):","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    mod = parse(LLVM.Module, \"\"\"\n        define i64 @\"add\"(i64 %0, i64 %1) {\n        top:\n          %2 = add i64 %1, %0\n          ret i64 %2\n        }\"\"\")\n\n    inst1, inst2 = instructions(entry(functions(mod)[\"add\"]))\nend","category":"page"},{"location":"man/values/","page":"Values","title":"Values","text":"julia> inst1\n%2 = add i64 %1, %0\n\njulia> inst2\nret i64 %2\n\njulia> replace_uses!(inst1, ConstantInt(Int64(42)))\n\njulia> inst2\nret i64 42","category":"page"},{"location":"man/analyses/#Analyses","page":"Analyses","title":"Analyses","text":"","category":"section"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"LLVM supports many analyses, but only few are available through the C API, and thus available in LLVM.jl.","category":"page"},{"location":"man/analyses/#IR-verification","page":"Analyses","title":"IR verification","text":"","category":"section"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"IR contained in modules and functions can be verified using the verify function, throwing a Julia exception when the IR is invalid:","category":"page"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"julia> mod = parse(LLVM.Module,  \"\"\"\n         define i32 @example(i1 %cond, i32 %val) {\n         entry:\n           br i1 %cond, label %foo, label %bar\n         foo:\n           %ret = add i32 %val, 1\n           br label %bar\n         bar:\n           ret i32 %ret\n         }\"\"\");\n\njulia> verify(mod)\nERROR: LLVM error: Instruction does not dominate all uses!\n  %ret = add i32 %val, 1\n  ret i32 %ret","category":"page"},{"location":"man/analyses/#Dominator-and-post-dominator","page":"Analyses","title":"Dominator and post-dominator","text":"","category":"section"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n      define i32 @example(i1 %cond, i32 %val) {\n      entry:\n        br i1 %cond, label %foo, label %bar\n      foo:\n        %ret = add i32 %val, 1\n        br label %bar\n      bar:\n        ret i32 %ret\n      }\"\"\"\n    mod = parse(LLVM.Module, ir)\n    fun = only(functions(mod))\n    entry, foo, bar = blocks(fun)\nend","category":"page"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"Dominator and post-dominator analyses can be performed on functions by constructing respectively a DomTree and PostDomTree object, and using the dominates function:","category":"page"},{"location":"man/analyses/","page":"Analyses","title":"Analyses","text":"julia> fun\ndefine i32 @example(i1 %cond, i32 %val) {\nentry:\n  br i1 %cond, label %foo, label %bar\n\nfoo:                                              ; preds = %entry\n  %ret = add i32 %val, 1\n  br label %bar\n\nbar:                                              ; preds = %foo, %entry\n  ret i32 %ret\n}\n\njulia> tree = DomTree(fun);\n\njulia> dominates(tree, first(instructions(entry)), first(instructions(foo)))\ntrue\njulia> dominates(tree, first(instructions(foo)), first(instructions(bar)))\nfalse\n\njulia> tree = PostDomTree(fun);\n\njulia> dominates(tree, first(instructions(bar)), first(instructions(foo)))\ntrue\n\njulia> dominates(tree, first(instructions(foo)), first(instructions(entry)))\nfalse","category":"page"},{"location":"lib/interop/#Julia-integration","page":"Julia integration","title":"Julia integration","text":"","category":"section"},{"location":"lib/interop/#Essentials","page":"Julia integration","title":"Essentials","text":"","category":"section"},{"location":"lib/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.Interop.isboxed\nLLVM.Interop.isghosttype\nLLVM.Interop.create_function\nLLVM.Interop.call_function","category":"page"},{"location":"lib/interop/#LLVM.Interop.isboxed","page":"Julia integration","title":"LLVM.Interop.isboxed","text":"isboxed(typ::Type)\n\nReturn if a type would be boxed when instantiated in the code generator.\n\n\n\n\n\n","category":"function"},{"location":"lib/interop/#LLVM.Interop.isghosttype","page":"Julia integration","title":"LLVM.Interop.isghosttype","text":"isghosttype(t::Type)\nisghosttype(T::LLVMType)\n\nCheck if a type is a ghost type, implying it would not be emitted by the Julia compiler. This only works for types created by the Julia compiler (living in its LLVM context).\n\n\n\n\n\n","category":"function"},{"location":"lib/interop/#LLVM.Interop.create_function","page":"Julia integration","title":"LLVM.Interop.create_function","text":"create_function(rettyp::LLVMType, argtyp::Vector{LLVMType}, [name::String])\n\nCreate an LLVM function, given its return type rettyp and a vector of argument types argtyp. The function is marked for inlining, to be embedded in the caller's body. Returns both the newly created function, and its type.\n\n\n\n\n\n","category":"function"},{"location":"lib/interop/#LLVM.Interop.call_function","page":"Julia integration","title":"LLVM.Interop.call_function","text":"call_function(f::LLVM.Function, rettyp::Type, argtyp::Type, args...)\n\nGenerate a call to an LLVM function f, given its return type rettyp and a tuple-type for the arguments. The arguments should be passed as a tuple expression containing the argument values (eg. :((1,2))), which will be splatted into the call to the function.\n\n\n\n\n\n","category":"function"},{"location":"lib/interop/#Calling-inline-assembly","page":"Julia integration","title":"Calling inline assembly","text":"","category":"section"},{"location":"lib/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.Interop.@asmcall","category":"page"},{"location":"lib/interop/#LLVM.Interop.@asmcall","page":"Julia integration","title":"LLVM.Interop.@asmcall","text":"@asmcall asm::String [constraints::String] [side_effects::Bool=false]\n         rettyp=Nothing argtyp=Tuple{} args...\n\nCall some inline assembly asm, optionally constrained by constraints and denoting other side effects in side_effects, specifying the return type in rettyp and types of arguments as a tuple-type in argtyp.\n\n\n\n\n\n","category":"macro"},{"location":"lib/interop/#LLVM-pointer-support","page":"Julia integration","title":"LLVM pointer support","text":"","category":"section"},{"location":"lib/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.Interop.@typed_ccall","category":"page"},{"location":"lib/interop/#LLVM.Interop.@typed_ccall","page":"Julia integration","title":"LLVM.Interop.@typed_ccall","text":"@typed_ccall(intrinsic, llvmcall, rettyp, (argtyps...), args...)\n\nPerform a ccall while more accurately preserving argument types like LLVM expects them:\n\nBools are passed as i1, not i8;\nPointers (both Ptr and Core.LLVMPtr) are passed as typed pointers (instead of resp. i8* and i64);\nVal-typed arguments will be passed as constants, if supported.\n\nThese features can be useful to call LLVM intrinsics, which may expect a specific set of argument types.\n\nnote: Note\nThis macro is not needed anymore on Julia 1.12, where the llvmcall ABI has been extended to preserve argument types more accurately.\n\n\n\n\n\n","category":"macro"},{"location":"lib/interop/#LLVM-intrinsics","page":"Julia integration","title":"LLVM intrinsics","text":"","category":"section"},{"location":"lib/interop/","page":"Julia integration","title":"Julia integration","text":"LLVM.Interop.trap\nLLVM.Interop.assume","category":"page"},{"location":"lib/interop/#LLVM.Interop.trap","page":"Julia integration","title":"LLVM.Interop.trap","text":"trap()\n\nTrap the program, causing it to abort.\n\n\n\n\n\n","category":"function"},{"location":"lib/interop/#LLVM.Interop.assume","page":"Julia integration","title":"LLVM.Interop.assume","text":"assume(cond::Bool)\n\nAssume that the condition cond is true. This is a hint to the compiler, possibly enabling it to optimize more aggressively.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#Essentials","page":"Essentials","title":"Essentials","text":"","category":"section"},{"location":"lib/essentials/#Initialization","page":"Essentials","title":"Initialization","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"LLVM.backends\nLLVM.InitializeAllTargetInfos\nLLVM.InitializeAllTargets\nLLVM.InitializeAllTargetMCs\nLLVM.InitializeAllAsmParsers\nLLVM.InitializeAllAsmPrinters\nLLVM.InitializeAllDisassemblers","category":"page"},{"location":"lib/essentials/#LLVM.backends","page":"Essentials","title":"LLVM.backends","text":"backends()\n\nReturn a list of back-ends supported by the LLVM library.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllTargetInfos","page":"Essentials","title":"LLVM.InitializeAllTargetInfos","text":"LLVM.InitializeAllTargetInfos()\nLLVM.InitializeXXXTargetInfo()\n\nEnables access to specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllTargets","page":"Essentials","title":"LLVM.InitializeAllTargets","text":"LLVM.InitializeAllTargets()\nLLVM.InitializeXXXTarget()\nLLVM.InitializeNativeTarget()\n\nEnables use of specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllTargetMCs","page":"Essentials","title":"LLVM.InitializeAllTargetMCs","text":"LLVM.InitializeAllTargetMCs()\nLLVM.InitializeXXXTargetMC()\n\nEnable use of machine code generation for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllAsmParsers","page":"Essentials","title":"LLVM.InitializeAllAsmParsers","text":"LLVM.InitializeAllAsmParsers()\nLLVM.InitializeXXXAsmParser()\nLLVM.InitializeNativeAsmParser()\n\nEnables use of assembly parsing functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllAsmPrinters","page":"Essentials","title":"LLVM.InitializeAllAsmPrinters","text":"LLVM.InitializeAllAsmPrinters()\nLLVM.InitializeXXXAsmPrinter()\nLLVM.InitializeNativeAsmPrinter()\n\nEnables use of assembly output functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.InitializeAllDisassemblers","page":"Essentials","title":"LLVM.InitializeAllDisassemblers","text":"LLVM.InitializeAllDisassemblers()\nLLVM.InitializeXXXDisassembler()\nLLVM.InitializeNativeDisassembler()\n\nEnables use of disassembly functionality for specific targets.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#Contexts","page":"Essentials","title":"Contexts","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"Context\nContext()\ndispose(::Context)\nsupports_typed_pointers","category":"page"},{"location":"lib/essentials/#LLVM.Context","page":"Essentials","title":"LLVM.Context","text":"LLVM.Context\n\nExecution state for the core LLVM IR system. Created by calling the Context() constructor, and should be disposed of.\n\nMost types are tied to a context instance. Multiple contexts can exist simultaneously. A single context is not thread safe. However, different contexts can execute on different threads simultaneously.\n\n\n\n\n\n","category":"type"},{"location":"lib/essentials/#LLVM.Context-Tuple{}","page":"Essentials","title":"LLVM.Context","text":"LLVM.Context(; opaque_pointers=nothing)\n\nCreate a new LLVM context. If opaque_pointers is true, the context will use opaque pointers instead of typed pointers (if suppoprted). Otherwise the behavior of the context depends on the LLVM version.\n\nThis object needs to be disposed of using dispose(::Context).\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.dispose-Tuple{Context}","page":"Essentials","title":"LLVM.dispose","text":"dispose(ctx::Context)\n\nDispose of the context, releasing all resources associated with it. The context should not be used after this operation.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.supports_typed_pointers","page":"Essentials","title":"LLVM.supports_typed_pointers","text":"supports_typed_pointers()\n\nCheck whether the current context supports typed pointers.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"LLVM.jl also tracks the context in task-local scope:","category":"page"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"context()\nactivate(::Context)\ndeactivate(::Context)\ncontext!","category":"page"},{"location":"lib/essentials/#LLVM.context-Tuple{}","page":"Essentials","title":"LLVM.context","text":"context(; throw_error::Bool=true)\n\nGet the active LLVM context for the current tasks. Throws an exception if no context is active, unless throw_error=false.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.activate-Tuple{Context}","page":"Essentials","title":"LLVM.activate","text":"activate(ctx::LLVM.Context)\n\nPushes a new context onto the context stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.deactivate-Tuple{Context}","page":"Essentials","title":"LLVM.deactivate","text":"deactivate(ctx::LLVM.Context)\n\nPops the current context from the context stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.context!","page":"Essentials","title":"LLVM.context!","text":"context!(ctx::LLVM.Context) do\n    ...\nend\n\nTemporarily activates the given context for the duration of the block.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"ts_context\nactivate(::ThreadSafeContext)\ndeactivate(::ThreadSafeContext)\nts_context!","category":"page"},{"location":"lib/essentials/#LLVM.ts_context","page":"Essentials","title":"LLVM.ts_context","text":"ts_context(; throw_error::Bool=true)\n\nGet the active LLVM thread-safe context for the current tasks. Throws an exception if no context is active, unless throw_error=false.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.activate-Tuple{ThreadSafeContext}","page":"Essentials","title":"LLVM.activate","text":"activate(ts_ctx::LLVM.ThreadSafeContext)\n\nPushes a new thread-safe context onto the context stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.deactivate-Tuple{ThreadSafeContext}","page":"Essentials","title":"LLVM.deactivate","text":"deactivate(ts_ctx::LLVM.ThreadSafeContext)\n\nPops the current thread-safe context from the context stack.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.ts_context!","page":"Essentials","title":"LLVM.ts_context!","text":"ts_context!(ts_ctx::LLVM.ThreadSafeContext) do\n    ...\nend\n\nTemporarily activates the given thread-safe context for the duration of the block.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#Resources","page":"Essentials","title":"Resources","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"@dispose","category":"page"},{"location":"lib/essentials/#LLVM.@dispose","page":"Essentials","title":"LLVM.@dispose","text":"@dispose foo=Foo() bar=Bar() begin\n    ...\nend\n\nHelper macro for disposing resources (by calling the dispose function for every resource in reverse order) after executing a block of code. This is often equivalent to calling the recourse constructor with do-block syntax, but without using (potentially costly) closures.\n\n\n\n\n\n","category":"macro"},{"location":"lib/essentials/#Exceptions","page":"Essentials","title":"Exceptions","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"LLVMException","category":"page"},{"location":"lib/essentials/#LLVM.LLVMException","page":"Essentials","title":"LLVM.LLVMException","text":"LLVMException\n\nException type for errors in the LLVM API. Possibly thrown by diagnostic handlers, and fatal eror handlers.\n\n\n\n\n\n","category":"type"},{"location":"lib/essentials/#Memory-buffers","page":"Essentials","title":"Memory buffers","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"MemoryBuffer\nMemoryBuffer(::Vector{T}, ::String, ::Bool) where {T<:Union{UInt8,Int8}}\nMemoryBufferFile\ndispose(::MemoryBuffer)","category":"page"},{"location":"lib/essentials/#LLVM.MemoryBuffer","page":"Essentials","title":"LLVM.MemoryBuffer","text":"MemoryBuffer\n\nA memory buffer representing a simple block of memory.\n\n\n\n\n\n","category":"type"},{"location":"lib/essentials/#LLVM.MemoryBuffer-Union{Tuple{T}, Tuple{Vector{T}, String, Bool}} where T<:Union{Int8, UInt8}","page":"Essentials","title":"LLVM.MemoryBuffer","text":"MemoryBuffer(data::Vector{T}, name::String=\"\", copy::Bool=true)\n\nCreate a memory buffer from the given data. If copy is true, the data is copied into the buffer. Otherwise, the user is responsible for keeping the data alive across the lifetime of the buffer.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#LLVM.MemoryBufferFile","page":"Essentials","title":"LLVM.MemoryBufferFile","text":"MemoryBufferFile(path::String)\n\nCreate a memory buffer from the contents of a file.\n\nThis object needs to be disposed of using dispose.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.dispose-Tuple{MemoryBuffer}","page":"Essentials","title":"LLVM.dispose","text":"dispose(membuf::MemoryBuffer)\n\nDispose of the given memory buffer.\n\n\n\n\n\n","category":"method"},{"location":"lib/essentials/#Other","page":"Essentials","title":"Other","text":"","category":"section"},{"location":"lib/essentials/","page":"Essentials","title":"Essentials","text":"LLVM.clopts\nLLVM.ismultithreaded","category":"page"},{"location":"lib/essentials/#LLVM.clopts","page":"Essentials","title":"LLVM.clopts","text":"clopts(opts...)\n\nParse the given arguments using the LLVM command-line parser.\n\nNote that this function modifies the global state of the LLVM library. It is also not safe to rely on the stability of the command-line options between different versions of LLVM.\n\n\n\n\n\n","category":"function"},{"location":"lib/essentials/#LLVM.ismultithreaded","page":"Essentials","title":"LLVM.ismultithreaded","text":"ismultithreaded()\n\nCheck whether LLVM is executing in thread-safe mode or not.\n\n\n\n\n\n","category":"function"},{"location":"man/metadata/#Metadata","page":"Metadata","title":"Metadata","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata is a way to attach additional information to various entities in LLVM IR. Various metadata object types exist, each prefixed with MD, and with a variety of APIs to query and manipulate them. The abstract supertype of all metadata objects is Metadata.","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata strings can be constructed with the MDString constructor, and converted back to Julia strings with a convert call:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> md = MDString(\"hello\")\n!\"hello\"\n\njulia> convert(String, md)\n\"hello\"","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Then there are metadata nodes, which can have other metadata as operands. For example, a tuple of metadata nodes can be created with the following MDNode constructor:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> md = MDNode([MDString(\"hello\"), MDString(\"world\")])\n<0x6000022c7f20> = !{!\"hello\", !\"world\"}","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"These operands can be extracted again using the operands function:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> operands(md)\n2-element Vector{MDString}:\n !\"hello\"\n !\"world\"","category":"page"},{"location":"man/metadata/#Converting-between-Metadata-and-Value","page":"Metadata","title":"Converting between Metadata and Value","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"It happens often that you want to put values in metadata, or use metadata with APIs that expect a value. In LLVM.jl, this is possible by using the Value and Metadata constructors with respectively Metadata and Value inputs, automatically wrapping them in the correct type:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> val = ConstantInt(42);\n\njulia> md = Metadata(val)\ni64 42\n\njulia> typeof(md)\nLLVM.ConstantAsMetadata","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> md = MDString(\"test\");\n\njulia> val = Value(md)\n!\"test\"\n\njulia> typeof(val)\nLLVM.MetadataAsValue","category":"page"},{"location":"man/metadata/#Inspecting-and-attaching","page":"Metadata","title":"Inspecting and attaching","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Any global value and instruction can have metadata attached to it. In LLVM.jl, it's possible to inspect and mutate that metadata using the metadata function:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n        define i64 @\"julia_+\"(i64 signext %0, i64 signext %1) {\n        top:\n          %2 = add i64 %1, %0\n          ret i64 %2\n        }\"\"\"\n    mod = parse(LLVM.Module, ir)\n    add = only(functions(mod))\n    bb = entry(add)\n    inst = first(instructions(bb))\nend","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> inst\n%2 = add i64 %1, %0\n\njulia> isempty(metadata(inst))\ntrue\n\njulia> metadata(inst)[\"dbg\"] = MDNode([MDString(\"hello\")])\n<0x5ff68c3f2f28> = !{!\"hello\"}\n\njulia> inst\n%2 = add i64 %1, %0, !dbg !0","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Metadata can also be attached to a module, in which case it needs to be grouped in a named metadata node (which can only contain other metadata nodes, and not e.g. strings directly). With LLVM's C API, module-level named metadata is append-only, which is done using the push! function:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> md = metadata(mod);\n\njulia> isempty(md)\ntrue\n\njulia> push!(md[\"hello\"], MDNode([MDString(\"world\")]));\n\njulia> md\nModuleMetadataIterator for module :\n  !hello = !{<0x60000394d3f8> = !{!\"world\"}}","category":"page"},{"location":"man/metadata/#Debug-information","page":"Metadata","title":"Debug information","text":"","category":"section"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"When generating IR, it is possible to add debug information metadata to the generated code. This information can be used by debuggers to provide a better debugging experience.","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"note: Note\nLLVM.jl currently does not offer extensive wrappers for generating debug info, and is mostly focussed on the ability to inspect or copy existing information.","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"LLVM represents debug information as a variety of DI-prefixed structures, which are subtypes of the above metadata types. In LLVM.jl, various functions are provided to inspect properties of these structures:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"DILocation: line, column, scope, inlined_at\nDIVariable: file, scope, line\nDIScope: file, name\nDIFile: directory, filename, source\nDIType: name, sizeof, offset, line, flags\nDISubProgram: line (and methods inherited from DIScope)","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"To query the debug info attached to an instruction, one queries the !dbg metadata using metadata(inst)[\"dbg\"].","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\n\n    ir = \"\"\"\n        define i64 @\"julia_+\"(i64 signext %0, i64 signext %1) !dbg !5 {\n        top:\n          %2 = add i64 %1, %0, !dbg !15\n          ret i64 %2, !dbg !15\n        }\n\n        !llvm.module.flags = !{!0, !1, !2}\n        !llvm.dbg.cu = !{!3}\n\n        !0 = !{i32 2, !\"Dwarf Version\", i32 4}\n        !1 = !{i32 2, !\"Debug Info Version\", i32 3}\n        !2 = !{i32 2, !\"julia.debug_level\", i32 1}\n        !3 = distinct !DICompileUnit(language: DW_LANG_Julia, file: !4, producer: \"julia\", isOptimized: true, runtimeVersion: 0, emissionKind: NoDebug, nameTableKind: GNU)\n        !4 = !DIFile(filename: \"julia\", directory: \".\")\n        !5 = distinct !DISubprogram(name: \"+\", linkageName: \"julia_+\", scope: null, file: !6, line: 87, type: !7, scopeLine: 87, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: !3, retainedNodes: !8)\n        !6 = !DIFile(filename: \"int.jl\", directory: \".\")\n        !7 = !DISubroutineType(types: !8)\n        !8 = !{}\n        !15 = !DILocation(line: 87, scope: !5)\"\"\"\n    mod = parse(LLVM.Module, ir)\n    add = only(functions(mod))\n    bb = entry(add)\n    inst = first(instructions(bb))\nend","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> inst\n%2 = add i64 %1, %0, !dbg !9\n\njulia> dbg = metadata(inst)[\"dbg\"]\n!DILocation(line: 87, scope: <0x6000056c5dd0>) = !DILocation(line: 87, scope: <0x6000056c5dd0>)\n\njulia> line(dbg)\n87\n\njulia> file(scope(dbg))\n<0x6000000beb80> = !DIFile(filename: \"int.jl\", directory: \".\")","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"Debug info can also be attached to functions, which can be queried and modified using respectively subprogram and subprogram!:","category":"page"},{"location":"man/metadata/","page":"Metadata","title":"Metadata","text":"julia> sp = subprogram(add)\n<0x600003edfad0> = distinct !DISubprogram(name: \"+\", linkageName: \"julia_+\", scope: null, file: <0x600003ba6fe0>, line: 87, type: <0x600003494c90>, scopeLine: 87, spFlags: DISPFlagDefinition | DISPFlagOptimized, unit: <0x6000021d8428>, retainedNodes: <0x6000010f09d0>)","category":"page"},{"location":"#LLVM.jl","page":"Home","title":"LLVM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia wrapper for LLVM.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package provides a wrapper for the LLVM compiler framework, based on the LLVM C API. You can use LLVM.jl to work with LLVM code generated by Julia, to interoperate with the Julia compiler, or to create your own compiler. It is heavily used by the different GPU compilers for the Julia programming language.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are different levels of abstraction and functionality available in this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"functionality in the top-level LLVM module: high-level wrappers for the LLVM C API, and additional functionality to make working with LLVM easier;\nfunctionality in LLVM.Interop: specific functionality to interoperate with the Julia compiler, and to work with LLVM code generated by Julia;\nfunctionality in the LLVM.API submodule: a direct mapping of the LLVM C API to Julia. This is useful when you need to work with the LLVM C API directly, or when you need functionality that is not yet wrapped in the top-level module.","category":"page"},{"location":"","page":"Home","title":"Home","text":"For installation instructions, please refer to the README.","category":"page"},{"location":"man/types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"DocTestSetup = quote\n    using LLVM\n\n    if context(; throw_error=false) === nothing\n        Context()\n    end\nend","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"LLVM has a rich type-system that is used to describe the types of values in a program. LLVM.jl attempts to reconstruct as much of this type-system as possible in Julia, beyond the abstractions that the C API provides (where types are opaque objects).","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Each type object, represented by a subtype of LLVMType, supports a few property functions:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"issized: whether the type has a fixed size (e.g. Int32).\ncontext: the context in which the type was created.\neltype: the element type of the type (if applicable, e.g., for arrays and vectors).","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"The types describing LLVM types are not exported by default, so always need to be prefixed by the LLVM module name.","category":"page"},{"location":"man/types/#Integer-types","page":"Types","title":"Integer types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Integer types are subtypes of the LLVM.IntegerType abstract type. They can be created using explicit constructors that encode the bit-width, or using constructors that take a width argument:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> LLVM.Int1Type()\ni1\n\njulia> LLVM.IntType(32)\ni32","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"It is possible to query the bit-width of an integer type using the width function:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> width(LLVM.Int32Type())\n32","category":"page"},{"location":"man/types/#Floating-point-types","page":"Types","title":"Floating-point types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Floating-point types are subtypes of the LLVM.FloatingPointType abstract type. They can only be constructed using explicitly named constructors:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> LLVM.HalfType()\nhalf\n\njulia> LLVM.BFloatType()\nbfloat","category":"page"},{"location":"man/types/#Function-types","page":"Types","title":"Function types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Function types are used to create functions, and encode both the return type and the argument types, which can be queried using respectively the return_type and parameters functions.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> LLVM.FunctionType(LLVM.Int1Type())\ni1 ()\n\njulia> ft = LLVM.FunctionType(LLVM.Int1Type(), [LLVM.FloatType()])\ni1 (float)\n\njulia> return_type(ft)\ni1\n\njulia> parameters(ft)\n1-element Vector{LLVMType}:\n float","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"To create vararg functions, the vararg keyword argument to the FunctionType constructor can be used. This property can be queried using the isvararg function.","category":"page"},{"location":"man/types/#Pointer-types","page":"Types","title":"Pointer types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Pointer types are represented by the LLVM.PointerType type. Depending on the LLVM version, they can be opaque or have an element type that can be queried using the eltype function:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> supports_typed_pointers()\ntrue\n\njulia> ty = LLVM.PointerType(LLVM.Int1Type())\ni1*\n\njulia> eltype(ty)\ni1","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> supports_typed_pointers()\nfalse\n\njulia> ty = LLVM.PointerType()\nptr\n\njulia> eltype(ty)\nERROR: Taking the type of an opaque pointer is illegal","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"When constructing a pointer type, you can also set the address space, and query it back using the addrspace function:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ty = LLVM.PointerType(LLVM.Int1Type(), 1)\ni1 addrspace(1)*\n\njulia> addrspace(ty)\n1","category":"page"},{"location":"man/types/#Array-types","page":"Types","title":"Array types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"LLVM arrays represent a fixed-size, homoeneous collection of elements. They can be created using the LLVM.ArrayType constructor:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ty = LLVM.ArrayType(LLVM.Int1Type(), 8)\n[8 x i1]\n\njulia> length(ty)\n8\n\njulia> eltype(ty)\ni1","category":"page"},{"location":"man/types/#Vector-types","page":"Types","title":"Vector types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"LLVM vectors are similar, but mostly used for SIMD operations:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ty = LLVM.VectorType(LLVM.Int1Type(), 8)\n<8 x i1>\n\njulia> length(ty)\n8\n\njulia> eltype(ty)\ni1","category":"page"},{"location":"man/types/#Structure-types","page":"Types","title":"Structure types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Structure types are used to represent a collection of elements of different types. They can be created using the LLVM.StructType constructor:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ty = LLVM.StructType([LLVM.Int32Type(), LLVM.FloatType()])\n{ i32, float }","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"It is also possible to start with an empty type and add elements to it:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ty = LLVM.StructType(\"MyStruct\")\n%MyStruct = type opaque\n\njulia> elements!(ty, [LLVM.Int32Type(), LLVM.FloatType()])\n\njulia> ty\n%MyStruct = type { i32, float }","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Structure types support a number of queries:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"name: the name of the structure type.\nelements: the element types of the structure type.\nispacked: whether the structure is packed.\nisopaque: whether the structure is opaque.\nisempty: whether the structure is empty.","category":"page"},{"location":"man/types/#Other-types","page":"Types","title":"Other types","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"There are a few other types that do not fit in a specific category:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"LLVM.VoidType: the void type.\nLLVM.LabelType: the label type.\nLLVM.MetadataType: the metadata type.\nLLVM.TokenType: the token type.","category":"page"},{"location":"man/types/#Type-iteration","page":"Types","title":"Type iteration","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"Although uncommon, it is possible to iterate the types that are registered in a context using the iterator returned by the types function. This iterator is not actually iterable, but it can be used to check whether a type is registered in a context:","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"julia> ctx = context();\n\njulia> haskey(types(ctx), \"Foo\")\nfalse\n\njulia> ty = LLVM.StructType(\"Foo\")\n%Foo = type opaque\n\njulia> haskey(types(ctx), \"Foo\")\ntrue\n\njulia> types(ctx)[\"Foo\"]\n%Foo = type opaque","category":"page"},{"location":"lib/values/#Values","page":"Values","title":"Values","text":"","category":"section"},{"location":"lib/values/#General-APIs","page":"Values","title":"General APIs","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"LLVM.Value\nvalue_type\ncontext(::Value)\nname(::Value)\nname!(::Value, ::String)\nisconstant(::Value)\nisundef\nispoison\nisnull","category":"page"},{"location":"lib/values/#LLVM.Value","page":"Values","title":"LLVM.Value","text":"LLVM.Value\n\nAbstract type representing an LLVM value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.value_type","page":"Values","title":"LLVM.value_type","text":"value_type(val::Value)\n\nGet the type of the given value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.context-Tuple{Value}","page":"Values","title":"LLVM.context","text":"context(val::LLVM.Value)\n\nReturn the context in which the given value was created.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.name-Tuple{Value}","page":"Values","title":"LLVM.name","text":"name(val::Value)\n\nGet the name of the given value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.name!-Tuple{Value, String}","page":"Values","title":"LLVM.name!","text":"name!(val::Value, name::String)\n\nSet the name of the given value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.isconstant-Tuple{Value}","page":"Values","title":"LLVM.isconstant","text":"isconstant(val::LLVM.Value)\n\nCheck if the given value is a constant value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.isundef","page":"Values","title":"LLVM.isundef","text":"isundef(val::LLVM.Value)\n\nCheck if the given value is an undef value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.ispoison","page":"Values","title":"LLVM.ispoison","text":"ispoison(val::LLVM.Value)\n\nCheck if the given value is a poison value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.isnull","page":"Values","title":"LLVM.isnull","text":"isnull(val::LLVM.Value)\n\nCheck if the given value is a null constant.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#User-values","page":"Values","title":"User values","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"LLVM.User\noperands(::LLVM.User)","category":"page"},{"location":"lib/values/#LLVM.User","page":"Values","title":"LLVM.User","text":"LLVM.User <: LLVM.Value\n\nA value that uses other values.\n\nSee also: operands.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.operands-Tuple{LLVM.User}","page":"Values","title":"LLVM.operands","text":"operands(user::LLVM.User)\n\nGet an iterator over the operands of the given user.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#Constant-values","page":"Values","title":"Constant values","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"LLVM.Constant\nnull\nall_ones\nPointerNull\nUndefValue\nPoisonValue\nConstantInt\nconvert(::Type, val::ConstantInt)\nConstantFP\nconvert(::Type{T}, val::ConstantFP) where {T<:AbstractFloat}\nConstantStruct\nConstantDataArray\nConstantDataArray(::LLVMType, ::AbstractVector{T}) where {T <: Union{Integer, AbstractFloat}}\nConstantDataArray(::AbstractVector)\nConstantDataVector\nConstantArray\nConstantArray(::LLVMType, ::AbstractArray{<:LLVM.Constant,N}) where {N}\nConstantArray(::AbstractArray)\ncollect(::ConstantArray)\nInlineAsm\nLLVM.ConstantExpr","category":"page"},{"location":"lib/values/#LLVM.Constant","page":"Values","title":"LLVM.Constant","text":"LLVM.Constant <: LLVM.User\n\nAbstract supertype for all constant values.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.null","page":"Values","title":"LLVM.null","text":"null(typ::LLVMType)\n\nCreate a null constant of the given type.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.all_ones","page":"Values","title":"LLVM.all_ones","text":"all_ones(typ::LLVMType)\n\nCreate a constant with all bits set to one of the given type.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.PointerNull","page":"Values","title":"LLVM.PointerNull","text":"PointerNull <: LLVM.ConstantData\n\nA null pointer constant.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.UndefValue","page":"Values","title":"LLVM.UndefValue","text":"UndefValue <: LLVM.ConstantData\n\nAn undefined constant value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.PoisonValue","page":"Values","title":"LLVM.PoisonValue","text":"PoisonValue <: LLVM.ConstantData\n\nA poison constant value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantInt","page":"Values","title":"LLVM.ConstantInt","text":"ConstantInt <: LLVM.ConstantData\n\nA constant integer value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#Base.convert-Tuple{Type, ConstantInt}","page":"Values","title":"Base.convert","text":"convert(::Type{<:Integer}, val::ConstantInt)\n\nConvert a constant integer value back to a Julia integer.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.ConstantFP","page":"Values","title":"LLVM.ConstantFP","text":"ConstantFP <: LLVM.ConstantData\n\nA constant floating point value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#Base.convert-Union{Tuple{T}, Tuple{Type{T}, ConstantFP}} where T<:AbstractFloat","page":"Values","title":"Base.convert","text":"convert(::Type{<:AbstractFloat}, val::ConstantFP)\n\nConvert a constant floating point value back to a Julia floating point number.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.ConstantStruct","page":"Values","title":"LLVM.ConstantStruct","text":"ConstantStruct <: LLVM.ConstantAggregate\n\nA constant struct of values.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantDataArray","page":"Values","title":"LLVM.ConstantDataArray","text":"ConstantDataArray <: LLVM.ConstantDataSequential\n\nA constant array of simple data values, i.e., whose element type is a simple 1/2/4/8-byte integer or half/bfloat/float/double, and whose elements are just simple data values\n\nSee also: ConstantArray\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantDataArray-Union{Tuple{T}, Tuple{LLVMType, AbstractVector{T}}} where T<:Union{AbstractFloat, Integer}","page":"Values","title":"LLVM.ConstantDataArray","text":"ConstantDataArray(typ::LLVMType, data::AbstractVector)\n\nCreate a constant array of simple data values of the given type and data.\n\nwarning: Warning\nThe memory layout of the data array must match the expected layout of the LLVM type.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.ConstantDataArray-Tuple{AbstractVector}","page":"Values","title":"LLVM.ConstantDataArray","text":"ConstantDataArray(data::AbstractVector)\n\nCreate a constant array of simple data values from a Julia vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.ConstantDataVector","page":"Values","title":"LLVM.ConstantDataVector","text":"ConstantDataVector <: LLVM.ConstantDataSequential\n\nA constant vector of simple data values, i.e., whose element type is a simple 1/2/4/8-byte integer or half/bfloat/float/double, and whose elements are just simple data values\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantArray","page":"Values","title":"LLVM.ConstantArray","text":"ConstantArray <: LLVM.ConstantAggregate\n\nA constant array of values.\n\nThis type implements the Julia array interface, so (to some extent) it can be used as a regular Julia array.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantArray-Union{Tuple{N}, Tuple{LLVMType, AbstractArray{<:LLVM.Constant, N}}} where N","page":"Values","title":"LLVM.ConstantArray","text":"ConstantArray(typ::LLVMType, data::AbstractArray)\n\nCreate a constant array of values of the given type and data.\n\nnote: Note\nWhen using simple data types, this constructor can also return a ConstantDataArray.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.ConstantArray-Tuple{AbstractArray}","page":"Values","title":"LLVM.ConstantArray","text":"ConstantArray(data::AbstractArray)\n\nCreate a constant array of values from a Julia array, using the appropriate constant type.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#Base.collect-Tuple{ConstantArray}","page":"Values","title":"Base.collect","text":"collect(ca::ConstantArray)\n\nConvert a constant array back to a Julia array.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.InlineAsm","page":"Values","title":"LLVM.InlineAsm","text":"InlineAsm <: LLVM.Constant\n\nA constant inline assembly block.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.ConstantExpr","page":"Values","title":"LLVM.ConstantExpr","text":"LLVM.ConstantExpr <: LLVM.Constant\n\nA constant value that is initialized with an expression using other constant values.\n\nConstant expressions are created using const_-prefixed functions, which correspond to the LLVM IR instructions: const_neg, const_not, etc.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#Global-values","page":"Values","title":"Global values","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"LLVM.GlobalValue\nglobal_value_type\nLLVM.parent(::LLVM.GlobalValue)\nisdeclaration\nlinkage\nlinkage!\nsection\nsection!\nvisibility\nvisibility!\ndllstorage\ndllstorage!\nunnamed_addr\nunnamed_addr!\nalignment(::LLVM.GlobalValue)\nalignment!(::LLVM.GlobalValue, ::Integer)","category":"page"},{"location":"lib/values/#LLVM.GlobalValue","page":"Values","title":"LLVM.GlobalValue","text":"LLVM.GlobalValue <: LLVM.Constant\n\nAbstract supertype for all global values.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.global_value_type","page":"Values","title":"LLVM.global_value_type","text":"global_value_type(val::LLVM.GlobalValue)\n\nGet the type of the global value.\n\nThis differs from value_type in that it returns the type of the contained value, not the type of the global value itself which is always a pointer type.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.parent-Tuple{GlobalValue}","page":"Values","title":"LLVM.parent","text":"parent(val::LLVM.GlobalValue)\n\nGet the parent module of the global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.isdeclaration","page":"Values","title":"LLVM.isdeclaration","text":"isdeclaration(val::LLVM.GlobalValue)\n\nCheck if the global value is a declaration, i.e. it does not have a definition.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.linkage","page":"Values","title":"LLVM.linkage","text":"linkage(val::LLVM.GlobalValue)\n\nGet the linkage of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.linkage!","page":"Values","title":"LLVM.linkage!","text":"linkage!(val::LLVM.GlobalValue, linkage::LLVM.LLVMLinkage)\n\nSet the linkage of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.section","page":"Values","title":"LLVM.section","text":"section(val::LLVM.GlobalValue)\n\nGet the section of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.section!","page":"Values","title":"LLVM.section!","text":"section!(val::LLVM.GlobalValue, sec::String)\n\nSet the section of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.visibility","page":"Values","title":"LLVM.visibility","text":"visibility(val::LLVM.GlobalValue)\n\nGet the visibility of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.visibility!","page":"Values","title":"LLVM.visibility!","text":"visibility!(val::LLVM.GlobalValue, viz::LLVM.LLVMVisibility)\n\nSet the visibility of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.dllstorage","page":"Values","title":"LLVM.dllstorage","text":"dllstorage(val::LLVM.GlobalValue)\n\nGet the DLL storage class of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.dllstorage!","page":"Values","title":"LLVM.dllstorage!","text":"dllstorage!(val::LLVM.GlobalValue, storage::LLVM.LLVMDLLStorageClass)\n\nSet the DLL storage class of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.unnamed_addr","page":"Values","title":"LLVM.unnamed_addr","text":"unnamed_addr(val::LLVM.GlobalValue)\n\nCheck if the global value has the unnamed address flag set.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.unnamed_addr!","page":"Values","title":"LLVM.unnamed_addr!","text":"unnamed_addr!(val::LLVM.GlobalValue, flag::Bool)\n\nSet the unnamed address flag of the global value.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.alignment-Tuple{GlobalValue}","page":"Values","title":"LLVM.alignment","text":"alignment(val::LLVM.GlobalValue)\n\nGet the alignment of the global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.alignment!-Tuple{GlobalValue, Integer}","page":"Values","title":"LLVM.alignment!","text":"alignment!(val::LLVM.GlobalValue, bytes::Integer)\n\nSet the alignment of the global value.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#Global-variables","page":"Values","title":"Global variables","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"Global variables are a specific kind of global values, and have additional APIs:","category":"page"},{"location":"lib/values/","page":"Values","title":"Values","text":"GlobalVariable\nerase!(::GlobalVariable)\ninitializer\ninitializer!\nisthreadlocal\nthreadlocal!\nthreadlocalmode\nthreadlocalmode!\nisconstant(::GlobalVariable)\nconstant!\nisextinit\nextinit!","category":"page"},{"location":"lib/values/#LLVM.GlobalVariable","page":"Values","title":"LLVM.GlobalVariable","text":"GlobalVariable <: LLVM.GlobalObject\n\nA global variable.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.erase!-Tuple{GlobalVariable}","page":"Values","title":"LLVM.erase!","text":"erase!(gv::GlobalVariable)\n\nRemove the global variable from its parent module and delete it.\n\nwarning: Warning\nThis function is unsafe as it does not check if the global variable is still used elsewhere.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.initializer","page":"Values","title":"LLVM.initializer","text":"initializer(gv::GlobalVariable)\n\nGet the initializer of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.initializer!","page":"Values","title":"LLVM.initializer!","text":"initializer!(gv::GlobalVariable, val::Constant)\n\nSet the initializer of the global variable. Setting the value to nothing removes the current initializer.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.isthreadlocal","page":"Values","title":"LLVM.isthreadlocal","text":"isthreadlocal(gv::GlobalVariable)\n\nCheck if the global variable is thread-local.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.threadlocal!","page":"Values","title":"LLVM.threadlocal!","text":"threadlocal!(gv::GlobalVariable, flag::Bool)\n\nSet the thread-local flag of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.threadlocalmode","page":"Values","title":"LLVM.threadlocalmode","text":"threadlocalmode(gv::GlobalVariable)\n\nGet the thread-local mode of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.threadlocalmode!","page":"Values","title":"LLVM.threadlocalmode!","text":"threadlocalmode!(gv::GlobalVariable, mode::LLVM.LLVMThreadLocalMode)\n\nSet the thread-local mode of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.isconstant-Tuple{GlobalVariable}","page":"Values","title":"LLVM.isconstant","text":"isconstant(gv::GlobalVariable)\n\nCheck if the global variable is a global constant, i.e., its value is immutable throughout the runtime execution of the program.\n\n\n\n\n\n","category":"method"},{"location":"lib/values/#LLVM.constant!","page":"Values","title":"LLVM.constant!","text":"constant!(gv::GlobalVariable, flag::Bool)\n\nSet the constant flag of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.isextinit","page":"Values","title":"LLVM.isextinit","text":"isextinit(gv::GlobalVariable)\n\nCheck if the global variable is externally initialized.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.extinit!","page":"Values","title":"LLVM.extinit!","text":"extinit!(gv::GlobalVariable, flag::Bool)\n\nSet the externally initialized flag of the global variable.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#Uses","page":"Values","title":"Uses","text":"","category":"section"},{"location":"lib/values/","page":"Values","title":"Values","text":"replace_uses!\nreplace_metadata_uses!\nuses\nUse\nuser\nvalue","category":"page"},{"location":"lib/values/#LLVM.replace_uses!","page":"Values","title":"LLVM.replace_uses!","text":"replace_uses!(old::LLVM.Value, new::LLVM.Value)\n\nReplace all uses of an old value in the IR with new.\n\nThis does not replace uses in metadata, which must be done separately with replace_metadata_uses!.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.replace_metadata_uses!","page":"Values","title":"LLVM.replace_metadata_uses!","text":"replace_metadata_uses!(old::LLVM.Value, new::LLVM.Value)\n\nReplace all uses of an old value in metadata with new.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.uses","page":"Values","title":"LLVM.uses","text":"uses(val::LLVM.Value)\n\nGet an iterator over the uses of the given value.\n\nSee also: LLVM.Use.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.Use","page":"Values","title":"LLVM.Use","text":"LLVM.Use\n\nA use of a value in the IR. Knows both the user and the used value.\n\nSee also: user, value.\n\n\n\n\n\n","category":"type"},{"location":"lib/values/#LLVM.user","page":"Values","title":"LLVM.user","text":"user(use::LLVM.Use)\n\nGet the user of the given use.\n\n\n\n\n\n","category":"function"},{"location":"lib/values/#LLVM.value","page":"Values","title":"LLVM.value","text":"value(use::LLVM.Use)\n\nGet the used value of the given use.\n\n\n\n\n\n","category":"function"}]
}
